"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/history";
exports.ids = ["vendor-chunks/history"];
exports.modules = {

/***/ "(rsc)/./node_modules/history/esm/history.js":
/*!*********************************************!*\
  !*** ./node_modules/history/esm/history.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createBrowserHistory: () => (/* binding */ createBrowserHistory),\n/* harmony export */   createHashHistory: () => (/* binding */ createHashHistory),\n/* harmony export */   createLocation: () => (/* binding */ createLocation),\n/* harmony export */   createMemoryHistory: () => (/* binding */ createMemoryHistory),\n/* harmony export */   createPath: () => (/* binding */ createPath),\n/* harmony export */   locationsAreEqual: () => (/* binding */ locationsAreEqual),\n/* harmony export */   parsePath: () => (/* binding */ parsePath)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(rsc)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var resolve_pathname__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! resolve-pathname */ \"(rsc)/./node_modules/resolve-pathname/esm/resolve-pathname.js\");\n/* harmony import */ var value_equal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! value-equal */ \"(rsc)/./node_modules/value-equal/esm/value-equal.js\");\n/* harmony import */ var tiny_warning__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tiny-warning */ \"(rsc)/./node_modules/tiny-warning/dist/tiny-warning.esm.js\");\n/* harmony import */ var tiny_invariant__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tiny-invariant */ \"(rsc)/./node_modules/tiny-invariant/dist/esm/tiny-invariant.js\");\n\n\n\n\n\nfunction addLeadingSlash(path) {\n    return path.charAt(0) === \"/\" ? path : \"/\" + path;\n}\nfunction stripLeadingSlash(path) {\n    return path.charAt(0) === \"/\" ? path.substr(1) : path;\n}\nfunction hasBasename(path, prefix) {\n    return path.toLowerCase().indexOf(prefix.toLowerCase()) === 0 && \"/?#\".indexOf(path.charAt(prefix.length)) !== -1;\n}\nfunction stripBasename(path, prefix) {\n    return hasBasename(path, prefix) ? path.substr(prefix.length) : path;\n}\nfunction stripTrailingSlash(path) {\n    return path.charAt(path.length - 1) === \"/\" ? path.slice(0, -1) : path;\n}\nfunction parsePath(path) {\n    var pathname = path || \"/\";\n    var search = \"\";\n    var hash = \"\";\n    var hashIndex = pathname.indexOf(\"#\");\n    if (hashIndex !== -1) {\n        hash = pathname.substr(hashIndex);\n        pathname = pathname.substr(0, hashIndex);\n    }\n    var searchIndex = pathname.indexOf(\"?\");\n    if (searchIndex !== -1) {\n        search = pathname.substr(searchIndex);\n        pathname = pathname.substr(0, searchIndex);\n    }\n    return {\n        pathname: pathname,\n        search: search === \"?\" ? \"\" : search,\n        hash: hash === \"#\" ? \"\" : hash\n    };\n}\nfunction createPath(location) {\n    var pathname = location.pathname, search = location.search, hash = location.hash;\n    var path = pathname || \"/\";\n    if (search && search !== \"?\") path += search.charAt(0) === \"?\" ? search : \"?\" + search;\n    if (hash && hash !== \"#\") path += hash.charAt(0) === \"#\" ? hash : \"#\" + hash;\n    return path;\n}\nfunction createLocation(path, state, key, currentLocation) {\n    var location;\n    if (typeof path === \"string\") {\n        // Two-arg form: push(path, state)\n        location = parsePath(path);\n        location.state = state;\n    } else {\n        // One-arg form: push(location)\n        location = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, path);\n        if (location.pathname === undefined) location.pathname = \"\";\n        if (location.search) {\n            if (location.search.charAt(0) !== \"?\") location.search = \"?\" + location.search;\n        } else {\n            location.search = \"\";\n        }\n        if (location.hash) {\n            if (location.hash.charAt(0) !== \"#\") location.hash = \"#\" + location.hash;\n        } else {\n            location.hash = \"\";\n        }\n        if (state !== undefined && location.state === undefined) location.state = state;\n    }\n    try {\n        location.pathname = decodeURI(location.pathname);\n    } catch (e) {\n        if (e instanceof URIError) {\n            throw new URIError('Pathname \"' + location.pathname + '\" could not be decoded. ' + \"This is likely caused by an invalid percent-encoding.\");\n        } else {\n            throw e;\n        }\n    }\n    if (key) location.key = key;\n    if (currentLocation) {\n        // Resolve incomplete/relative pathname relative to current location.\n        if (!location.pathname) {\n            location.pathname = currentLocation.pathname;\n        } else if (location.pathname.charAt(0) !== \"/\") {\n            location.pathname = (0,resolve_pathname__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(location.pathname, currentLocation.pathname);\n        }\n    } else {\n        // When there is no prior location and pathname is empty, set it to /\n        if (!location.pathname) {\n            location.pathname = \"/\";\n        }\n    }\n    return location;\n}\nfunction locationsAreEqual(a, b) {\n    return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && (0,value_equal__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(a.state, b.state);\n}\nfunction createTransitionManager() {\n    var prompt = null;\n    function setPrompt(nextPrompt) {\n         true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(prompt == null, \"A history supports only one prompt at a time\") : 0;\n        prompt = nextPrompt;\n        return function() {\n            if (prompt === nextPrompt) prompt = null;\n        };\n    }\n    function confirmTransitionTo(location, action, getUserConfirmation, callback) {\n        // TODO: If another transition starts while we're still confirming\n        // the previous one, we may end up in a weird state. Figure out the\n        // best way to handle this.\n        if (prompt != null) {\n            var result = typeof prompt === \"function\" ? prompt(location, action) : prompt;\n            if (typeof result === \"string\") {\n                if (typeof getUserConfirmation === \"function\") {\n                    getUserConfirmation(result, callback);\n                } else {\n                     true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(false, \"A history needs a getUserConfirmation function in order to use a prompt message\") : 0;\n                    callback(true);\n                }\n            } else {\n                // Return false from a transition hook to cancel the transition.\n                callback(result !== false);\n            }\n        } else {\n            callback(true);\n        }\n    }\n    var listeners = [];\n    function appendListener(fn) {\n        var isActive = true;\n        function listener() {\n            if (isActive) fn.apply(void 0, arguments);\n        }\n        listeners.push(listener);\n        return function() {\n            isActive = false;\n            listeners = listeners.filter(function(item) {\n                return item !== listener;\n            });\n        };\n    }\n    function notifyListeners() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        listeners.forEach(function(listener) {\n            return listener.apply(void 0, args);\n        });\n    }\n    return {\n        setPrompt: setPrompt,\n        confirmTransitionTo: confirmTransitionTo,\n        appendListener: appendListener,\n        notifyListeners: notifyListeners\n    };\n}\nvar canUseDOM = !!( false && 0);\nfunction getConfirmation(message, callback) {\n    callback(window.confirm(message)); // eslint-disable-line no-alert\n}\n/**\n * Returns true if the HTML5 history API is supported. Taken from Modernizr.\n *\n * https://github.com/Modernizr/Modernizr/blob/master/LICENSE\n * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js\n * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586\n */ function supportsHistory() {\n    var ua = window.navigator.userAgent;\n    if ((ua.indexOf(\"Android 2.\") !== -1 || ua.indexOf(\"Android 4.0\") !== -1) && ua.indexOf(\"Mobile Safari\") !== -1 && ua.indexOf(\"Chrome\") === -1 && ua.indexOf(\"Windows Phone\") === -1) return false;\n    return window.history && \"pushState\" in window.history;\n}\n/**\n * Returns true if browser fires popstate on hash change.\n * IE10 and IE11 do not.\n */ function supportsPopStateOnHashChange() {\n    return window.navigator.userAgent.indexOf(\"Trident\") === -1;\n}\n/**\n * Returns false if using go(n) with hash history causes a full page reload.\n */ function supportsGoWithoutReloadUsingHash() {\n    return window.navigator.userAgent.indexOf(\"Firefox\") === -1;\n}\n/**\n * Returns true if a given popstate event is an extraneous WebKit event.\n * Accounts for the fact that Chrome on iOS fires real popstate events\n * containing undefined state when pressing the back button.\n */ function isExtraneousPopstateEvent(event) {\n    return event.state === undefined && navigator.userAgent.indexOf(\"CriOS\") === -1;\n}\nvar PopStateEvent = \"popstate\";\nvar HashChangeEvent = \"hashchange\";\nfunction getHistoryState() {\n    try {\n        return window.history.state || {};\n    } catch (e) {\n        // IE 11 sometimes throws when accessing window.history.state\n        // See https://github.com/ReactTraining/history/pull/289\n        return {};\n    }\n}\n/**\n * Creates a history object that uses the HTML5 history API including\n * pushState, replaceState, and the popstate event.\n */ function createBrowserHistory(props) {\n    if (props === void 0) {\n        props = {};\n    }\n    !canUseDOM ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(false, \"Browser history needs a DOM\") : 0 : void 0;\n    var globalHistory = window.history;\n    var canUseHistory = supportsHistory();\n    var needsHashChangeListener = !supportsPopStateOnHashChange();\n    var _props = props, _props$forceRefresh = _props.forceRefresh, forceRefresh = _props$forceRefresh === void 0 ? false : _props$forceRefresh, _props$getUserConfirm = _props.getUserConfirmation, getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm, _props$keyLength = _props.keyLength, keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;\n    var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : \"\";\n    function getDOMLocation(historyState) {\n        var _ref = historyState || {}, key = _ref.key, state = _ref.state;\n        var _window$location = window.location, pathname = _window$location.pathname, search = _window$location.search, hash = _window$location.hash;\n        var path = pathname + search + hash;\n         true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(!basename || hasBasename(path, basename), \"You are attempting to use a basename on a page whose URL path does not begin \" + 'with the basename. Expected path \"' + path + '\" to begin with \"' + basename + '\".') : 0;\n        if (basename) path = stripBasename(path, basename);\n        return createLocation(path, state, key);\n    }\n    function createKey() {\n        return Math.random().toString(36).substr(2, keyLength);\n    }\n    var transitionManager = createTransitionManager();\n    function setState(nextState) {\n        (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(history, nextState);\n        history.length = globalHistory.length;\n        transitionManager.notifyListeners(history.location, history.action);\n    }\n    function handlePopState(event) {\n        // Ignore extraneous popstate events in WebKit.\n        if (isExtraneousPopstateEvent(event)) return;\n        handlePop(getDOMLocation(event.state));\n    }\n    function handleHashChange() {\n        handlePop(getDOMLocation(getHistoryState()));\n    }\n    var forceNextPop = false;\n    function handlePop(location) {\n        if (forceNextPop) {\n            forceNextPop = false;\n            setState();\n        } else {\n            var action = \"POP\";\n            transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {\n                if (ok) {\n                    setState({\n                        action: action,\n                        location: location\n                    });\n                } else {\n                    revertPop(location);\n                }\n            });\n        }\n    }\n    function revertPop(fromLocation) {\n        var toLocation = history.location; // TODO: We could probably make this more reliable by\n        // keeping a list of keys we've seen in sessionStorage.\n        // Instead, we just default to 0 for keys we don't know.\n        var toIndex = allKeys.indexOf(toLocation.key);\n        if (toIndex === -1) toIndex = 0;\n        var fromIndex = allKeys.indexOf(fromLocation.key);\n        if (fromIndex === -1) fromIndex = 0;\n        var delta = toIndex - fromIndex;\n        if (delta) {\n            forceNextPop = true;\n            go(delta);\n        }\n    }\n    var initialLocation = getDOMLocation(getHistoryState());\n    var allKeys = [\n        initialLocation.key\n    ]; // Public interface\n    function createHref(location) {\n        return basename + createPath(location);\n    }\n    function push(path, state) {\n         true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(!(typeof path === \"object\" && path.state !== undefined && state !== undefined), \"You should avoid providing a 2nd state argument to push when the 1st \" + \"argument is a location-like object that already has state; it is ignored\") : 0;\n        var action = \"PUSH\";\n        var location = createLocation(path, state, createKey(), history.location);\n        transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {\n            if (!ok) return;\n            var href = createHref(location);\n            var key = location.key, state = location.state;\n            if (canUseHistory) {\n                globalHistory.pushState({\n                    key: key,\n                    state: state\n                }, null, href);\n                if (forceRefresh) {\n                    window.location.href = href;\n                } else {\n                    var prevIndex = allKeys.indexOf(history.location.key);\n                    var nextKeys = allKeys.slice(0, prevIndex + 1);\n                    nextKeys.push(location.key);\n                    allKeys = nextKeys;\n                    setState({\n                        action: action,\n                        location: location\n                    });\n                }\n            } else {\n                 true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(state === undefined, \"Browser history cannot push state in browsers that do not support HTML5 history\") : 0;\n                window.location.href = href;\n            }\n        });\n    }\n    function replace(path, state) {\n         true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(!(typeof path === \"object\" && path.state !== undefined && state !== undefined), \"You should avoid providing a 2nd state argument to replace when the 1st \" + \"argument is a location-like object that already has state; it is ignored\") : 0;\n        var action = \"REPLACE\";\n        var location = createLocation(path, state, createKey(), history.location);\n        transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {\n            if (!ok) return;\n            var href = createHref(location);\n            var key = location.key, state = location.state;\n            if (canUseHistory) {\n                globalHistory.replaceState({\n                    key: key,\n                    state: state\n                }, null, href);\n                if (forceRefresh) {\n                    window.location.replace(href);\n                } else {\n                    var prevIndex = allKeys.indexOf(history.location.key);\n                    if (prevIndex !== -1) allKeys[prevIndex] = location.key;\n                    setState({\n                        action: action,\n                        location: location\n                    });\n                }\n            } else {\n                 true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(state === undefined, \"Browser history cannot replace state in browsers that do not support HTML5 history\") : 0;\n                window.location.replace(href);\n            }\n        });\n    }\n    function go(n) {\n        globalHistory.go(n);\n    }\n    function goBack() {\n        go(-1);\n    }\n    function goForward() {\n        go(1);\n    }\n    var listenerCount = 0;\n    function checkDOMListeners(delta) {\n        listenerCount += delta;\n        if (listenerCount === 1 && delta === 1) {\n            window.addEventListener(PopStateEvent, handlePopState);\n            if (needsHashChangeListener) window.addEventListener(HashChangeEvent, handleHashChange);\n        } else if (listenerCount === 0) {\n            window.removeEventListener(PopStateEvent, handlePopState);\n            if (needsHashChangeListener) window.removeEventListener(HashChangeEvent, handleHashChange);\n        }\n    }\n    var isBlocked = false;\n    function block(prompt) {\n        if (prompt === void 0) {\n            prompt = false;\n        }\n        var unblock = transitionManager.setPrompt(prompt);\n        if (!isBlocked) {\n            checkDOMListeners(1);\n            isBlocked = true;\n        }\n        return function() {\n            if (isBlocked) {\n                isBlocked = false;\n                checkDOMListeners(-1);\n            }\n            return unblock();\n        };\n    }\n    function listen(listener) {\n        var unlisten = transitionManager.appendListener(listener);\n        checkDOMListeners(1);\n        return function() {\n            checkDOMListeners(-1);\n            unlisten();\n        };\n    }\n    var history = {\n        length: globalHistory.length,\n        action: \"POP\",\n        location: initialLocation,\n        createHref: createHref,\n        push: push,\n        replace: replace,\n        go: go,\n        goBack: goBack,\n        goForward: goForward,\n        block: block,\n        listen: listen\n    };\n    return history;\n}\nvar HashChangeEvent$1 = \"hashchange\";\nvar HashPathCoders = {\n    hashbang: {\n        encodePath: function encodePath(path) {\n            return path.charAt(0) === \"!\" ? path : \"!/\" + stripLeadingSlash(path);\n        },\n        decodePath: function decodePath(path) {\n            return path.charAt(0) === \"!\" ? path.substr(1) : path;\n        }\n    },\n    noslash: {\n        encodePath: stripLeadingSlash,\n        decodePath: addLeadingSlash\n    },\n    slash: {\n        encodePath: addLeadingSlash,\n        decodePath: addLeadingSlash\n    }\n};\nfunction stripHash(url) {\n    var hashIndex = url.indexOf(\"#\");\n    return hashIndex === -1 ? url : url.slice(0, hashIndex);\n}\nfunction getHashPath() {\n    // We can't use window.location.hash here because it's not\n    // consistent across browsers - Firefox will pre-decode it!\n    var href = window.location.href;\n    var hashIndex = href.indexOf(\"#\");\n    return hashIndex === -1 ? \"\" : href.substring(hashIndex + 1);\n}\nfunction pushHashPath(path) {\n    window.location.hash = path;\n}\nfunction replaceHashPath(path) {\n    window.location.replace(stripHash(window.location.href) + \"#\" + path);\n}\nfunction createHashHistory(props) {\n    if (props === void 0) {\n        props = {};\n    }\n    !canUseDOM ?  true ? (0,tiny_invariant__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(false, \"Hash history needs a DOM\") : 0 : void 0;\n    var globalHistory = window.history;\n    var canGoWithoutReload = supportsGoWithoutReloadUsingHash();\n    var _props = props, _props$getUserConfirm = _props.getUserConfirmation, getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm, _props$hashType = _props.hashType, hashType = _props$hashType === void 0 ? \"slash\" : _props$hashType;\n    var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : \"\";\n    var _HashPathCoders$hashT = HashPathCoders[hashType], encodePath = _HashPathCoders$hashT.encodePath, decodePath = _HashPathCoders$hashT.decodePath;\n    function getDOMLocation() {\n        var path = decodePath(getHashPath());\n         true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(!basename || hasBasename(path, basename), \"You are attempting to use a basename on a page whose URL path does not begin \" + 'with the basename. Expected path \"' + path + '\" to begin with \"' + basename + '\".') : 0;\n        if (basename) path = stripBasename(path, basename);\n        return createLocation(path);\n    }\n    var transitionManager = createTransitionManager();\n    function setState(nextState) {\n        (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(history, nextState);\n        history.length = globalHistory.length;\n        transitionManager.notifyListeners(history.location, history.action);\n    }\n    var forceNextPop = false;\n    var ignorePath = null;\n    function locationsAreEqual$$1(a, b) {\n        return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash;\n    }\n    function handleHashChange() {\n        var path = getHashPath();\n        var encodedPath = encodePath(path);\n        if (path !== encodedPath) {\n            // Ensure we always have a properly-encoded hash.\n            replaceHashPath(encodedPath);\n        } else {\n            var location = getDOMLocation();\n            var prevLocation = history.location;\n            if (!forceNextPop && locationsAreEqual$$1(prevLocation, location)) return; // A hashchange doesn't always == location change.\n            if (ignorePath === createPath(location)) return; // Ignore this change; we already setState in push/replace.\n            ignorePath = null;\n            handlePop(location);\n        }\n    }\n    function handlePop(location) {\n        if (forceNextPop) {\n            forceNextPop = false;\n            setState();\n        } else {\n            var action = \"POP\";\n            transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {\n                if (ok) {\n                    setState({\n                        action: action,\n                        location: location\n                    });\n                } else {\n                    revertPop(location);\n                }\n            });\n        }\n    }\n    function revertPop(fromLocation) {\n        var toLocation = history.location; // TODO: We could probably make this more reliable by\n        // keeping a list of paths we've seen in sessionStorage.\n        // Instead, we just default to 0 for paths we don't know.\n        var toIndex = allPaths.lastIndexOf(createPath(toLocation));\n        if (toIndex === -1) toIndex = 0;\n        var fromIndex = allPaths.lastIndexOf(createPath(fromLocation));\n        if (fromIndex === -1) fromIndex = 0;\n        var delta = toIndex - fromIndex;\n        if (delta) {\n            forceNextPop = true;\n            go(delta);\n        }\n    } // Ensure the hash is encoded properly before doing anything else.\n    var path = getHashPath();\n    var encodedPath = encodePath(path);\n    if (path !== encodedPath) replaceHashPath(encodedPath);\n    var initialLocation = getDOMLocation();\n    var allPaths = [\n        createPath(initialLocation)\n    ]; // Public interface\n    function createHref(location) {\n        var baseTag = document.querySelector(\"base\");\n        var href = \"\";\n        if (baseTag && baseTag.getAttribute(\"href\")) {\n            href = stripHash(window.location.href);\n        }\n        return href + \"#\" + encodePath(basename + createPath(location));\n    }\n    function push(path, state) {\n         true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(state === undefined, \"Hash history cannot push state; it is ignored\") : 0;\n        var action = \"PUSH\";\n        var location = createLocation(path, undefined, undefined, history.location);\n        transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {\n            if (!ok) return;\n            var path = createPath(location);\n            var encodedPath = encodePath(basename + path);\n            var hashChanged = getHashPath() !== encodedPath;\n            if (hashChanged) {\n                // We cannot tell if a hashchange was caused by a PUSH, so we'd\n                // rather setState here and ignore the hashchange. The caveat here\n                // is that other hash histories in the page will consider it a POP.\n                ignorePath = path;\n                pushHashPath(encodedPath);\n                var prevIndex = allPaths.lastIndexOf(createPath(history.location));\n                var nextPaths = allPaths.slice(0, prevIndex + 1);\n                nextPaths.push(path);\n                allPaths = nextPaths;\n                setState({\n                    action: action,\n                    location: location\n                });\n            } else {\n                 true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(false, \"Hash history cannot PUSH the same path; a new entry will not be added to the history stack\") : 0;\n                setState();\n            }\n        });\n    }\n    function replace(path, state) {\n         true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(state === undefined, \"Hash history cannot replace state; it is ignored\") : 0;\n        var action = \"REPLACE\";\n        var location = createLocation(path, undefined, undefined, history.location);\n        transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {\n            if (!ok) return;\n            var path = createPath(location);\n            var encodedPath = encodePath(basename + path);\n            var hashChanged = getHashPath() !== encodedPath;\n            if (hashChanged) {\n                // We cannot tell if a hashchange was caused by a REPLACE, so we'd\n                // rather setState here and ignore the hashchange. The caveat here\n                // is that other hash histories in the page will consider it a POP.\n                ignorePath = path;\n                replaceHashPath(encodedPath);\n            }\n            var prevIndex = allPaths.indexOf(createPath(history.location));\n            if (prevIndex !== -1) allPaths[prevIndex] = path;\n            setState({\n                action: action,\n                location: location\n            });\n        });\n    }\n    function go(n) {\n         true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(canGoWithoutReload, \"Hash history go(n) causes a full page reload in this browser\") : 0;\n        globalHistory.go(n);\n    }\n    function goBack() {\n        go(-1);\n    }\n    function goForward() {\n        go(1);\n    }\n    var listenerCount = 0;\n    function checkDOMListeners(delta) {\n        listenerCount += delta;\n        if (listenerCount === 1 && delta === 1) {\n            window.addEventListener(HashChangeEvent$1, handleHashChange);\n        } else if (listenerCount === 0) {\n            window.removeEventListener(HashChangeEvent$1, handleHashChange);\n        }\n    }\n    var isBlocked = false;\n    function block(prompt) {\n        if (prompt === void 0) {\n            prompt = false;\n        }\n        var unblock = transitionManager.setPrompt(prompt);\n        if (!isBlocked) {\n            checkDOMListeners(1);\n            isBlocked = true;\n        }\n        return function() {\n            if (isBlocked) {\n                isBlocked = false;\n                checkDOMListeners(-1);\n            }\n            return unblock();\n        };\n    }\n    function listen(listener) {\n        var unlisten = transitionManager.appendListener(listener);\n        checkDOMListeners(1);\n        return function() {\n            checkDOMListeners(-1);\n            unlisten();\n        };\n    }\n    var history = {\n        length: globalHistory.length,\n        action: \"POP\",\n        location: initialLocation,\n        createHref: createHref,\n        push: push,\n        replace: replace,\n        go: go,\n        goBack: goBack,\n        goForward: goForward,\n        block: block,\n        listen: listen\n    };\n    return history;\n}\nfunction clamp(n, lowerBound, upperBound) {\n    return Math.min(Math.max(n, lowerBound), upperBound);\n}\n/**\n * Creates a history object that stores locations in memory.\n */ function createMemoryHistory(props) {\n    if (props === void 0) {\n        props = {};\n    }\n    var _props = props, getUserConfirmation = _props.getUserConfirmation, _props$initialEntries = _props.initialEntries, initialEntries = _props$initialEntries === void 0 ? [\n        \"/\"\n    ] : _props$initialEntries, _props$initialIndex = _props.initialIndex, initialIndex = _props$initialIndex === void 0 ? 0 : _props$initialIndex, _props$keyLength = _props.keyLength, keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;\n    var transitionManager = createTransitionManager();\n    function setState(nextState) {\n        (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(history, nextState);\n        history.length = history.entries.length;\n        transitionManager.notifyListeners(history.location, history.action);\n    }\n    function createKey() {\n        return Math.random().toString(36).substr(2, keyLength);\n    }\n    var index = clamp(initialIndex, 0, initialEntries.length - 1);\n    var entries = initialEntries.map(function(entry) {\n        return typeof entry === \"string\" ? createLocation(entry, undefined, createKey()) : createLocation(entry, undefined, entry.key || createKey());\n    }); // Public interface\n    var createHref = createPath;\n    function push(path, state) {\n         true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(!(typeof path === \"object\" && path.state !== undefined && state !== undefined), \"You should avoid providing a 2nd state argument to push when the 1st \" + \"argument is a location-like object that already has state; it is ignored\") : 0;\n        var action = \"PUSH\";\n        var location = createLocation(path, state, createKey(), history.location);\n        transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {\n            if (!ok) return;\n            var prevIndex = history.index;\n            var nextIndex = prevIndex + 1;\n            var nextEntries = history.entries.slice(0);\n            if (nextEntries.length > nextIndex) {\n                nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);\n            } else {\n                nextEntries.push(location);\n            }\n            setState({\n                action: action,\n                location: location,\n                index: nextIndex,\n                entries: nextEntries\n            });\n        });\n    }\n    function replace(path, state) {\n         true ? (0,tiny_warning__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(!(typeof path === \"object\" && path.state !== undefined && state !== undefined), \"You should avoid providing a 2nd state argument to replace when the 1st \" + \"argument is a location-like object that already has state; it is ignored\") : 0;\n        var action = \"REPLACE\";\n        var location = createLocation(path, state, createKey(), history.location);\n        transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {\n            if (!ok) return;\n            history.entries[history.index] = location;\n            setState({\n                action: action,\n                location: location\n            });\n        });\n    }\n    function go(n) {\n        var nextIndex = clamp(history.index + n, 0, history.entries.length - 1);\n        var action = \"POP\";\n        var location = history.entries[nextIndex];\n        transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {\n            if (ok) {\n                setState({\n                    action: action,\n                    location: location,\n                    index: nextIndex\n                });\n            } else {\n                // Mimic the behavior of DOM histories by\n                // causing a render after a cancelled POP.\n                setState();\n            }\n        });\n    }\n    function goBack() {\n        go(-1);\n    }\n    function goForward() {\n        go(1);\n    }\n    function canGo(n) {\n        var nextIndex = history.index + n;\n        return nextIndex >= 0 && nextIndex < history.entries.length;\n    }\n    function block(prompt) {\n        if (prompt === void 0) {\n            prompt = false;\n        }\n        return transitionManager.setPrompt(prompt);\n    }\n    function listen(listener) {\n        return transitionManager.appendListener(listener);\n    }\n    var history = {\n        length: entries.length,\n        action: \"POP\",\n        location: entries[index],\n        index: index,\n        entries: entries,\n        createHref: createHref,\n        push: push,\n        replace: replace,\n        go: go,\n        goBack: goBack,\n        goForward: goForward,\n        canGo: canGo,\n        block: block,\n        listen: listen\n    };\n    return history;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9lc20vaGlzdG9yeS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBMEQ7QUFDWDtBQUNWO0FBQ0Y7QUFDSTtBQUV2QyxTQUFTSyxnQkFBZ0JDLElBQUk7SUFDM0IsT0FBT0EsS0FBS0MsTUFBTSxDQUFDLE9BQU8sTUFBTUQsT0FBTyxNQUFNQTtBQUMvQztBQUNBLFNBQVNFLGtCQUFrQkYsSUFBSTtJQUM3QixPQUFPQSxLQUFLQyxNQUFNLENBQUMsT0FBTyxNQUFNRCxLQUFLRyxNQUFNLENBQUMsS0FBS0g7QUFDbkQ7QUFDQSxTQUFTSSxZQUFZSixJQUFJLEVBQUVLLE1BQU07SUFDL0IsT0FBT0wsS0FBS00sV0FBVyxHQUFHQyxPQUFPLENBQUNGLE9BQU9DLFdBQVcsUUFBUSxLQUFLLE1BQU1DLE9BQU8sQ0FBQ1AsS0FBS0MsTUFBTSxDQUFDSSxPQUFPRyxNQUFNLE9BQU8sQ0FBQztBQUNsSDtBQUNBLFNBQVNDLGNBQWNULElBQUksRUFBRUssTUFBTTtJQUNqQyxPQUFPRCxZQUFZSixNQUFNSyxVQUFVTCxLQUFLRyxNQUFNLENBQUNFLE9BQU9HLE1BQU0sSUFBSVI7QUFDbEU7QUFDQSxTQUFTVSxtQkFBbUJWLElBQUk7SUFDOUIsT0FBT0EsS0FBS0MsTUFBTSxDQUFDRCxLQUFLUSxNQUFNLEdBQUcsT0FBTyxNQUFNUixLQUFLVyxLQUFLLENBQUMsR0FBRyxDQUFDLEtBQUtYO0FBQ3BFO0FBQ0EsU0FBU1ksVUFBVVosSUFBSTtJQUNyQixJQUFJYSxXQUFXYixRQUFRO0lBQ3ZCLElBQUljLFNBQVM7SUFDYixJQUFJQyxPQUFPO0lBQ1gsSUFBSUMsWUFBWUgsU0FBU04sT0FBTyxDQUFDO0lBRWpDLElBQUlTLGNBQWMsQ0FBQyxHQUFHO1FBQ3BCRCxPQUFPRixTQUFTVixNQUFNLENBQUNhO1FBQ3ZCSCxXQUFXQSxTQUFTVixNQUFNLENBQUMsR0FBR2E7SUFDaEM7SUFFQSxJQUFJQyxjQUFjSixTQUFTTixP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U0FBU0E7UUFDVDFELFlBQVlBO1FBQ1psRSxNQUFNQTtRQUNOdUUsU0FBU0E7UUFDVFAsSUFBSUE7UUFDSlUsUUFBUUE7UUFDUkMsV0FBV0E7UUFDWHdELE9BQU9BO1FBQ1BsRCxPQUFPQTtRQUNQRSxRQUFRQTtJQUNWO0lBQ0EsT0FBTy9EO0FBQ1Q7QUFFa0kiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXNtL2hpc3RvcnkuanM/ZjJjNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX2V4dGVuZHMgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcyc7XG5pbXBvcnQgcmVzb2x2ZVBhdGhuYW1lIGZyb20gJ3Jlc29sdmUtcGF0aG5hbWUnO1xuaW1wb3J0IHZhbHVlRXF1YWwgZnJvbSAndmFsdWUtZXF1YWwnO1xuaW1wb3J0IHdhcm5pbmcgZnJvbSAndGlueS13YXJuaW5nJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAndGlueS1pbnZhcmlhbnQnO1xuXG5mdW5jdGlvbiBhZGRMZWFkaW5nU2xhc2gocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJyA/IHBhdGggOiAnLycgKyBwYXRoO1xufVxuZnVuY3Rpb24gc3RyaXBMZWFkaW5nU2xhc2gocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJyA/IHBhdGguc3Vic3RyKDEpIDogcGF0aDtcbn1cbmZ1bmN0aW9uIGhhc0Jhc2VuYW1lKHBhdGgsIHByZWZpeCkge1xuICByZXR1cm4gcGF0aC50b0xvd2VyQ2FzZSgpLmluZGV4T2YocHJlZml4LnRvTG93ZXJDYXNlKCkpID09PSAwICYmICcvPyMnLmluZGV4T2YocGF0aC5jaGFyQXQocHJlZml4Lmxlbmd0aCkpICE9PSAtMTtcbn1cbmZ1bmN0aW9uIHN0cmlwQmFzZW5hbWUocGF0aCwgcHJlZml4KSB7XG4gIHJldHVybiBoYXNCYXNlbmFtZShwYXRoLCBwcmVmaXgpID8gcGF0aC5zdWJzdHIocHJlZml4Lmxlbmd0aCkgOiBwYXRoO1xufVxuZnVuY3Rpb24gc3RyaXBUcmFpbGluZ1NsYXNoKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KHBhdGgubGVuZ3RoIC0gMSkgPT09ICcvJyA/IHBhdGguc2xpY2UoMCwgLTEpIDogcGF0aDtcbn1cbmZ1bmN0aW9uIHBhcnNlUGF0aChwYXRoKSB7XG4gIHZhciBwYXRobmFtZSA9IHBhdGggfHwgJy8nO1xuICB2YXIgc2VhcmNoID0gJyc7XG4gIHZhciBoYXNoID0gJyc7XG4gIHZhciBoYXNoSW5kZXggPSBwYXRobmFtZS5pbmRleE9mKCcjJyk7XG5cbiAgaWYgKGhhc2hJbmRleCAhPT0gLTEpIHtcbiAgICBoYXNoID0gcGF0aG5hbWUuc3Vic3RyKGhhc2hJbmRleCk7XG4gICAgcGF0aG5hbWUgPSBwYXRobmFtZS5zdWJzdHIoMCwgaGFzaEluZGV4KTtcbiAgfVxuXG4gIHZhciBzZWFyY2hJbmRleCA9IHBhdGhuYW1lLmluZGV4T2YoJz8nKTtcblxuICBpZiAoc2VhcmNoSW5kZXggIT09IC0xKSB7XG4gICAgc2VhcmNoID0gcGF0aG5hbWUuc3Vic3RyKHNlYXJjaEluZGV4KTtcbiAgICBwYXRobmFtZSA9IHBhdGhuYW1lLnN1YnN0cigwLCBzZWFyY2hJbmRleCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBhdGhuYW1lOiBwYXRobmFtZSxcbiAgICBzZWFyY2g6IHNlYXJjaCA9PT0gJz8nID8gJycgOiBzZWFyY2gsXG4gICAgaGFzaDogaGFzaCA9PT0gJyMnID8gJycgOiBoYXNoXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVQYXRoKGxvY2F0aW9uKSB7XG4gIHZhciBwYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgc2VhcmNoID0gbG9jYXRpb24uc2VhcmNoLFxuICAgICAgaGFzaCA9IGxvY2F0aW9uLmhhc2g7XG4gIHZhciBwYXRoID0gcGF0aG5hbWUgfHwgJy8nO1xuICBpZiAoc2VhcmNoICYmIHNlYXJjaCAhPT0gJz8nKSBwYXRoICs9IHNlYXJjaC5jaGFyQXQoMCkgPT09ICc/JyA/IHNlYXJjaCA6IFwiP1wiICsgc2VhcmNoO1xuICBpZiAoaGFzaCAmJiBoYXNoICE9PSAnIycpIHBhdGggKz0gaGFzaC5jaGFyQXQoMCkgPT09ICcjJyA/IGhhc2ggOiBcIiNcIiArIGhhc2g7XG4gIHJldHVybiBwYXRoO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMb2NhdGlvbihwYXRoLCBzdGF0ZSwga2V5LCBjdXJyZW50TG9jYXRpb24pIHtcbiAgdmFyIGxvY2F0aW9uO1xuXG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBUd28tYXJnIGZvcm06IHB1c2gocGF0aCwgc3RhdGUpXG4gICAgbG9jYXRpb24gPSBwYXJzZVBhdGgocGF0aCk7XG4gICAgbG9jYXRpb24uc3RhdGUgPSBzdGF0ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBPbmUtYXJnIGZvcm06IHB1c2gobG9jYXRpb24pXG4gICAgbG9jYXRpb24gPSBfZXh0ZW5kcyh7fSwgcGF0aCk7XG4gICAgaWYgKGxvY2F0aW9uLnBhdGhuYW1lID09PSB1bmRlZmluZWQpIGxvY2F0aW9uLnBhdGhuYW1lID0gJyc7XG5cbiAgICBpZiAobG9jYXRpb24uc2VhcmNoKSB7XG4gICAgICBpZiAobG9jYXRpb24uc2VhcmNoLmNoYXJBdCgwKSAhPT0gJz8nKSBsb2NhdGlvbi5zZWFyY2ggPSAnPycgKyBsb2NhdGlvbi5zZWFyY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvY2F0aW9uLnNlYXJjaCA9ICcnO1xuICAgIH1cblxuICAgIGlmIChsb2NhdGlvbi5oYXNoKSB7XG4gICAgICBpZiAobG9jYXRpb24uaGFzaC5jaGFyQXQoMCkgIT09ICcjJykgbG9jYXRpb24uaGFzaCA9ICcjJyArIGxvY2F0aW9uLmhhc2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvY2F0aW9uLmhhc2ggPSAnJztcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUgIT09IHVuZGVmaW5lZCAmJiBsb2NhdGlvbi5zdGF0ZSA9PT0gdW5kZWZpbmVkKSBsb2NhdGlvbi5zdGF0ZSA9IHN0YXRlO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBsb2NhdGlvbi5wYXRobmFtZSA9IGRlY29kZVVSSShsb2NhdGlvbi5wYXRobmFtZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIFVSSUVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgVVJJRXJyb3IoJ1BhdGhuYW1lIFwiJyArIGxvY2F0aW9uLnBhdGhuYW1lICsgJ1wiIGNvdWxkIG5vdCBiZSBkZWNvZGVkLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSBhbiBpbnZhbGlkIHBlcmNlbnQtZW5jb2RpbmcuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG5cbiAgaWYgKGtleSkgbG9jYXRpb24ua2V5ID0ga2V5O1xuXG4gIGlmIChjdXJyZW50TG9jYXRpb24pIHtcbiAgICAvLyBSZXNvbHZlIGluY29tcGxldGUvcmVsYXRpdmUgcGF0aG5hbWUgcmVsYXRpdmUgdG8gY3VycmVudCBsb2NhdGlvbi5cbiAgICBpZiAoIWxvY2F0aW9uLnBhdGhuYW1lKSB7XG4gICAgICBsb2NhdGlvbi5wYXRobmFtZSA9IGN1cnJlbnRMb2NhdGlvbi5wYXRobmFtZTtcbiAgICB9IGVsc2UgaWYgKGxvY2F0aW9uLnBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSB7XG4gICAgICBsb2NhdGlvbi5wYXRobmFtZSA9IHJlc29sdmVQYXRobmFtZShsb2NhdGlvbi5wYXRobmFtZSwgY3VycmVudExvY2F0aW9uLnBhdGhuYW1lKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gV2hlbiB0aGVyZSBpcyBubyBwcmlvciBsb2NhdGlvbiBhbmQgcGF0aG5hbWUgaXMgZW1wdHksIHNldCBpdCB0byAvXG4gICAgaWYgKCFsb2NhdGlvbi5wYXRobmFtZSkge1xuICAgICAgbG9jYXRpb24ucGF0aG5hbWUgPSAnLyc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxvY2F0aW9uO1xufVxuZnVuY3Rpb24gbG9jYXRpb25zQXJlRXF1YWwoYSwgYikge1xuICByZXR1cm4gYS5wYXRobmFtZSA9PT0gYi5wYXRobmFtZSAmJiBhLnNlYXJjaCA9PT0gYi5zZWFyY2ggJiYgYS5oYXNoID09PSBiLmhhc2ggJiYgYS5rZXkgPT09IGIua2V5ICYmIHZhbHVlRXF1YWwoYS5zdGF0ZSwgYi5zdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyKCkge1xuICB2YXIgcHJvbXB0ID0gbnVsbDtcblxuICBmdW5jdGlvbiBzZXRQcm9tcHQobmV4dFByb21wdCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcocHJvbXB0ID09IG51bGwsICdBIGhpc3Rvcnkgc3VwcG9ydHMgb25seSBvbmUgcHJvbXB0IGF0IGEgdGltZScpIDogdm9pZCAwO1xuICAgIHByb21wdCA9IG5leHRQcm9tcHQ7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChwcm9tcHQgPT09IG5leHRQcm9tcHQpIHByb21wdCA9IG51bGw7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgY2FsbGJhY2spIHtcbiAgICAvLyBUT0RPOiBJZiBhbm90aGVyIHRyYW5zaXRpb24gc3RhcnRzIHdoaWxlIHdlJ3JlIHN0aWxsIGNvbmZpcm1pbmdcbiAgICAvLyB0aGUgcHJldmlvdXMgb25lLCB3ZSBtYXkgZW5kIHVwIGluIGEgd2VpcmQgc3RhdGUuIEZpZ3VyZSBvdXQgdGhlXG4gICAgLy8gYmVzdCB3YXkgdG8gaGFuZGxlIHRoaXMuXG4gICAgaWYgKHByb21wdCAhPSBudWxsKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdHlwZW9mIHByb21wdCA9PT0gJ2Z1bmN0aW9uJyA/IHByb21wdChsb2NhdGlvbiwgYWN0aW9uKSA6IHByb21wdDtcblxuICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZ2V0VXNlckNvbmZpcm1hdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGdldFVzZXJDb25maXJtYXRpb24ocmVzdWx0LCBjYWxsYmFjayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgJ0EgaGlzdG9yeSBuZWVkcyBhIGdldFVzZXJDb25maXJtYXRpb24gZnVuY3Rpb24gaW4gb3JkZXIgdG8gdXNlIGEgcHJvbXB0IG1lc3NhZ2UnKSA6IHZvaWQgMDtcbiAgICAgICAgICBjYWxsYmFjayh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmV0dXJuIGZhbHNlIGZyb20gYSB0cmFuc2l0aW9uIGhvb2sgdG8gY2FuY2VsIHRoZSB0cmFuc2l0aW9uLlxuICAgICAgICBjYWxsYmFjayhyZXN1bHQgIT09IGZhbHNlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2sodHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGxpc3RlbmVycyA9IFtdO1xuXG4gIGZ1bmN0aW9uIGFwcGVuZExpc3RlbmVyKGZuKSB7XG4gICAgdmFyIGlzQWN0aXZlID0gdHJ1ZTtcblxuICAgIGZ1bmN0aW9uIGxpc3RlbmVyKCkge1xuICAgICAgaWYgKGlzQWN0aXZlKSBmbi5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbSAhPT0gbGlzdGVuZXI7XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbm90aWZ5TGlzdGVuZXJzKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBsaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBsaXN0ZW5lci5hcHBseSh2b2lkIDAsIGFyZ3MpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzZXRQcm9tcHQ6IHNldFByb21wdCxcbiAgICBjb25maXJtVHJhbnNpdGlvblRvOiBjb25maXJtVHJhbnNpdGlvblRvLFxuICAgIGFwcGVuZExpc3RlbmVyOiBhcHBlbmRMaXN0ZW5lcixcbiAgICBub3RpZnlMaXN0ZW5lcnM6IG5vdGlmeUxpc3RlbmVyc1xuICB9O1xufVxuXG52YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbmZ1bmN0aW9uIGdldENvbmZpcm1hdGlvbihtZXNzYWdlLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayh3aW5kb3cuY29uZmlybShtZXNzYWdlKSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tYWxlcnRcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBIVE1MNSBoaXN0b3J5IEFQSSBpcyBzdXBwb3J0ZWQuIFRha2VuIGZyb20gTW9kZXJuaXpyLlxuICpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9Nb2Rlcm5penIvTW9kZXJuaXpyL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9Nb2Rlcm5penIvTW9kZXJuaXpyL2Jsb2IvbWFzdGVyL2ZlYXR1cmUtZGV0ZWN0cy9oaXN0b3J5LmpzXG4gKiBjaGFuZ2VkIHRvIGF2b2lkIGZhbHNlIG5lZ2F0aXZlcyBmb3IgV2luZG93cyBQaG9uZXM6IGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdGpzL3JlYWN0LXJvdXRlci9pc3N1ZXMvNTg2XG4gKi9cblxuZnVuY3Rpb24gc3VwcG9ydHNIaXN0b3J5KCkge1xuICB2YXIgdWEgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgaWYgKCh1YS5pbmRleE9mKCdBbmRyb2lkIDIuJykgIT09IC0xIHx8IHVhLmluZGV4T2YoJ0FuZHJvaWQgNC4wJykgIT09IC0xKSAmJiB1YS5pbmRleE9mKCdNb2JpbGUgU2FmYXJpJykgIT09IC0xICYmIHVhLmluZGV4T2YoJ0Nocm9tZScpID09PSAtMSAmJiB1YS5pbmRleE9mKCdXaW5kb3dzIFBob25lJykgPT09IC0xKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB3aW5kb3cuaGlzdG9yeSAmJiAncHVzaFN0YXRlJyBpbiB3aW5kb3cuaGlzdG9yeTtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGJyb3dzZXIgZmlyZXMgcG9wc3RhdGUgb24gaGFzaCBjaGFuZ2UuXG4gKiBJRTEwIGFuZCBJRTExIGRvIG5vdC5cbiAqL1xuXG5mdW5jdGlvbiBzdXBwb3J0c1BvcFN0YXRlT25IYXNoQ2hhbmdlKCkge1xuICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignVHJpZGVudCcpID09PSAtMTtcbn1cbi8qKlxuICogUmV0dXJucyBmYWxzZSBpZiB1c2luZyBnbyhuKSB3aXRoIGhhc2ggaGlzdG9yeSBjYXVzZXMgYSBmdWxsIHBhZ2UgcmVsb2FkLlxuICovXG5cbmZ1bmN0aW9uIHN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoKCkge1xuICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRmlyZWZveCcpID09PSAtMTtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGEgZ2l2ZW4gcG9wc3RhdGUgZXZlbnQgaXMgYW4gZXh0cmFuZW91cyBXZWJLaXQgZXZlbnQuXG4gKiBBY2NvdW50cyBmb3IgdGhlIGZhY3QgdGhhdCBDaHJvbWUgb24gaU9TIGZpcmVzIHJlYWwgcG9wc3RhdGUgZXZlbnRzXG4gKiBjb250YWluaW5nIHVuZGVmaW5lZCBzdGF0ZSB3aGVuIHByZXNzaW5nIHRoZSBiYWNrIGJ1dHRvbi5cbiAqL1xuXG5mdW5jdGlvbiBpc0V4dHJhbmVvdXNQb3BzdGF0ZUV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBldmVudC5zdGF0ZSA9PT0gdW5kZWZpbmVkICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQ3JpT1MnKSA9PT0gLTE7XG59XG5cbnZhciBQb3BTdGF0ZUV2ZW50ID0gJ3BvcHN0YXRlJztcbnZhciBIYXNoQ2hhbmdlRXZlbnQgPSAnaGFzaGNoYW5nZSc7XG5cbmZ1bmN0aW9uIGdldEhpc3RvcnlTdGF0ZSgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93Lmhpc3Rvcnkuc3RhdGUgfHwge307XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBJRSAxMSBzb21ldGltZXMgdGhyb3dzIHdoZW4gYWNjZXNzaW5nIHdpbmRvdy5oaXN0b3J5LnN0YXRlXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9SZWFjdFRyYWluaW5nL2hpc3RvcnkvcHVsbC8yODlcbiAgICByZXR1cm4ge307XG4gIH1cbn1cbi8qKlxuICogQ3JlYXRlcyBhIGhpc3Rvcnkgb2JqZWN0IHRoYXQgdXNlcyB0aGUgSFRNTDUgaGlzdG9yeSBBUEkgaW5jbHVkaW5nXG4gKiBwdXNoU3RhdGUsIHJlcGxhY2VTdGF0ZSwgYW5kIHRoZSBwb3BzdGF0ZSBldmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJIaXN0b3J5KHByb3BzKSB7XG4gIGlmIChwcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgcHJvcHMgPSB7fTtcbiAgfVxuXG4gICFjYW5Vc2VET00gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdCcm93c2VyIGhpc3RvcnkgbmVlZHMgYSBET00nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHZhciBnbG9iYWxIaXN0b3J5ID0gd2luZG93Lmhpc3Rvcnk7XG4gIHZhciBjYW5Vc2VIaXN0b3J5ID0gc3VwcG9ydHNIaXN0b3J5KCk7XG4gIHZhciBuZWVkc0hhc2hDaGFuZ2VMaXN0ZW5lciA9ICFzdXBwb3J0c1BvcFN0YXRlT25IYXNoQ2hhbmdlKCk7XG4gIHZhciBfcHJvcHMgPSBwcm9wcyxcbiAgICAgIF9wcm9wcyRmb3JjZVJlZnJlc2ggPSBfcHJvcHMuZm9yY2VSZWZyZXNoLFxuICAgICAgZm9yY2VSZWZyZXNoID0gX3Byb3BzJGZvcmNlUmVmcmVzaCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkZm9yY2VSZWZyZXNoLFxuICAgICAgX3Byb3BzJGdldFVzZXJDb25maXJtID0gX3Byb3BzLmdldFVzZXJDb25maXJtYXRpb24sXG4gICAgICBnZXRVc2VyQ29uZmlybWF0aW9uID0gX3Byb3BzJGdldFVzZXJDb25maXJtID09PSB2b2lkIDAgPyBnZXRDb25maXJtYXRpb24gOiBfcHJvcHMkZ2V0VXNlckNvbmZpcm0sXG4gICAgICBfcHJvcHMka2V5TGVuZ3RoID0gX3Byb3BzLmtleUxlbmd0aCxcbiAgICAgIGtleUxlbmd0aCA9IF9wcm9wcyRrZXlMZW5ndGggPT09IHZvaWQgMCA/IDYgOiBfcHJvcHMka2V5TGVuZ3RoO1xuICB2YXIgYmFzZW5hbWUgPSBwcm9wcy5iYXNlbmFtZSA/IHN0cmlwVHJhaWxpbmdTbGFzaChhZGRMZWFkaW5nU2xhc2gocHJvcHMuYmFzZW5hbWUpKSA6ICcnO1xuXG4gIGZ1bmN0aW9uIGdldERPTUxvY2F0aW9uKGhpc3RvcnlTdGF0ZSkge1xuICAgIHZhciBfcmVmID0gaGlzdG9yeVN0YXRlIHx8IHt9LFxuICAgICAgICBrZXkgPSBfcmVmLmtleSxcbiAgICAgICAgc3RhdGUgPSBfcmVmLnN0YXRlO1xuXG4gICAgdmFyIF93aW5kb3ckbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb24sXG4gICAgICAgIHBhdGhuYW1lID0gX3dpbmRvdyRsb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgICAgc2VhcmNoID0gX3dpbmRvdyRsb2NhdGlvbi5zZWFyY2gsXG4gICAgICAgIGhhc2ggPSBfd2luZG93JGxvY2F0aW9uLmhhc2g7XG4gICAgdmFyIHBhdGggPSBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyghYmFzZW5hbWUgfHwgaGFzQmFzZW5hbWUocGF0aCwgYmFzZW5hbWUpLCAnWW91IGFyZSBhdHRlbXB0aW5nIHRvIHVzZSBhIGJhc2VuYW1lIG9uIGEgcGFnZSB3aG9zZSBVUkwgcGF0aCBkb2VzIG5vdCBiZWdpbiAnICsgJ3dpdGggdGhlIGJhc2VuYW1lLiBFeHBlY3RlZCBwYXRoIFwiJyArIHBhdGggKyAnXCIgdG8gYmVnaW4gd2l0aCBcIicgKyBiYXNlbmFtZSArICdcIi4nKSA6IHZvaWQgMDtcbiAgICBpZiAoYmFzZW5hbWUpIHBhdGggPSBzdHJpcEJhc2VuYW1lKHBhdGgsIGJhc2VuYW1lKTtcbiAgICByZXR1cm4gY3JlYXRlTG9jYXRpb24ocGF0aCwgc3RhdGUsIGtleSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVLZXkoKSB7XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCBrZXlMZW5ndGgpO1xuICB9XG5cbiAgdmFyIHRyYW5zaXRpb25NYW5hZ2VyID0gY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIoKTtcblxuICBmdW5jdGlvbiBzZXRTdGF0ZShuZXh0U3RhdGUpIHtcbiAgICBfZXh0ZW5kcyhoaXN0b3J5LCBuZXh0U3RhdGUpO1xuXG4gICAgaGlzdG9yeS5sZW5ndGggPSBnbG9iYWxIaXN0b3J5Lmxlbmd0aDtcbiAgICB0cmFuc2l0aW9uTWFuYWdlci5ub3RpZnlMaXN0ZW5lcnMoaGlzdG9yeS5sb2NhdGlvbiwgaGlzdG9yeS5hY3Rpb24pO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlUG9wU3RhdGUoZXZlbnQpIHtcbiAgICAvLyBJZ25vcmUgZXh0cmFuZW91cyBwb3BzdGF0ZSBldmVudHMgaW4gV2ViS2l0LlxuICAgIGlmIChpc0V4dHJhbmVvdXNQb3BzdGF0ZUV2ZW50KGV2ZW50KSkgcmV0dXJuO1xuICAgIGhhbmRsZVBvcChnZXRET01Mb2NhdGlvbihldmVudC5zdGF0ZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlSGFzaENoYW5nZSgpIHtcbiAgICBoYW5kbGVQb3AoZ2V0RE9NTG9jYXRpb24oZ2V0SGlzdG9yeVN0YXRlKCkpKTtcbiAgfVxuXG4gIHZhciBmb3JjZU5leHRQb3AgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBoYW5kbGVQb3AobG9jYXRpb24pIHtcbiAgICBpZiAoZm9yY2VOZXh0UG9wKSB7XG4gICAgICBmb3JjZU5leHRQb3AgPSBmYWxzZTtcbiAgICAgIHNldFN0YXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhY3Rpb24gPSAnUE9QJztcbiAgICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICAgIGlmIChvaykge1xuICAgICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV2ZXJ0UG9wKGxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmV2ZXJ0UG9wKGZyb21Mb2NhdGlvbikge1xuICAgIHZhciB0b0xvY2F0aW9uID0gaGlzdG9yeS5sb2NhdGlvbjsgLy8gVE9ETzogV2UgY291bGQgcHJvYmFibHkgbWFrZSB0aGlzIG1vcmUgcmVsaWFibGUgYnlcbiAgICAvLyBrZWVwaW5nIGEgbGlzdCBvZiBrZXlzIHdlJ3ZlIHNlZW4gaW4gc2Vzc2lvblN0b3JhZ2UuXG4gICAgLy8gSW5zdGVhZCwgd2UganVzdCBkZWZhdWx0IHRvIDAgZm9yIGtleXMgd2UgZG9uJ3Qga25vdy5cblxuICAgIHZhciB0b0luZGV4ID0gYWxsS2V5cy5pbmRleE9mKHRvTG9jYXRpb24ua2V5KTtcbiAgICBpZiAodG9JbmRleCA9PT0gLTEpIHRvSW5kZXggPSAwO1xuICAgIHZhciBmcm9tSW5kZXggPSBhbGxLZXlzLmluZGV4T2YoZnJvbUxvY2F0aW9uLmtleSk7XG4gICAgaWYgKGZyb21JbmRleCA9PT0gLTEpIGZyb21JbmRleCA9IDA7XG4gICAgdmFyIGRlbHRhID0gdG9JbmRleCAtIGZyb21JbmRleDtcblxuICAgIGlmIChkZWx0YSkge1xuICAgICAgZm9yY2VOZXh0UG9wID0gdHJ1ZTtcbiAgICAgIGdvKGRlbHRhKTtcbiAgICB9XG4gIH1cblxuICB2YXIgaW5pdGlhbExvY2F0aW9uID0gZ2V0RE9NTG9jYXRpb24oZ2V0SGlzdG9yeVN0YXRlKCkpO1xuICB2YXIgYWxsS2V5cyA9IFtpbml0aWFsTG9jYXRpb24ua2V5XTsgLy8gUHVibGljIGludGVyZmFjZVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUhyZWYobG9jYXRpb24pIHtcbiAgICByZXR1cm4gYmFzZW5hbWUgKyBjcmVhdGVQYXRoKGxvY2F0aW9uKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2gocGF0aCwgc3RhdGUpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCEodHlwZW9mIHBhdGggPT09ICdvYmplY3QnICYmIHBhdGguc3RhdGUgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZSAhPT0gdW5kZWZpbmVkKSwgJ1lvdSBzaG91bGQgYXZvaWQgcHJvdmlkaW5nIGEgMm5kIHN0YXRlIGFyZ3VtZW50IHRvIHB1c2ggd2hlbiB0aGUgMXN0ICcgKyAnYXJndW1lbnQgaXMgYSBsb2NhdGlvbi1saWtlIG9iamVjdCB0aGF0IGFscmVhZHkgaGFzIHN0YXRlOyBpdCBpcyBpZ25vcmVkJykgOiB2b2lkIDA7XG4gICAgdmFyIGFjdGlvbiA9ICdQVVNIJztcbiAgICB2YXIgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihwYXRoLCBzdGF0ZSwgY3JlYXRlS2V5KCksIGhpc3RvcnkubG9jYXRpb24pO1xuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAoIW9rKSByZXR1cm47XG4gICAgICB2YXIgaHJlZiA9IGNyZWF0ZUhyZWYobG9jYXRpb24pO1xuICAgICAgdmFyIGtleSA9IGxvY2F0aW9uLmtleSxcbiAgICAgICAgICBzdGF0ZSA9IGxvY2F0aW9uLnN0YXRlO1xuXG4gICAgICBpZiAoY2FuVXNlSGlzdG9yeSkge1xuICAgICAgICBnbG9iYWxIaXN0b3J5LnB1c2hTdGF0ZSh7XG4gICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgc3RhdGU6IHN0YXRlXG4gICAgICAgIH0sIG51bGwsIGhyZWYpO1xuXG4gICAgICAgIGlmIChmb3JjZVJlZnJlc2gpIHtcbiAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGhyZWY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHByZXZJbmRleCA9IGFsbEtleXMuaW5kZXhPZihoaXN0b3J5LmxvY2F0aW9uLmtleSk7XG4gICAgICAgICAgdmFyIG5leHRLZXlzID0gYWxsS2V5cy5zbGljZSgwLCBwcmV2SW5kZXggKyAxKTtcbiAgICAgICAgICBuZXh0S2V5cy5wdXNoKGxvY2F0aW9uLmtleSk7XG4gICAgICAgICAgYWxsS2V5cyA9IG5leHRLZXlzO1xuICAgICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoc3RhdGUgPT09IHVuZGVmaW5lZCwgJ0Jyb3dzZXIgaGlzdG9yeSBjYW5ub3QgcHVzaCBzdGF0ZSBpbiBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IEhUTUw1IGhpc3RvcnknKSA6IHZvaWQgMDtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBocmVmO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVwbGFjZShwYXRoLCBzdGF0ZSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoISh0eXBlb2YgcGF0aCA9PT0gJ29iamVjdCcgJiYgcGF0aC5zdGF0ZSAhPT0gdW5kZWZpbmVkICYmIHN0YXRlICE9PSB1bmRlZmluZWQpLCAnWW91IHNob3VsZCBhdm9pZCBwcm92aWRpbmcgYSAybmQgc3RhdGUgYXJndW1lbnQgdG8gcmVwbGFjZSB3aGVuIHRoZSAxc3QgJyArICdhcmd1bWVudCBpcyBhIGxvY2F0aW9uLWxpa2Ugb2JqZWN0IHRoYXQgYWxyZWFkeSBoYXMgc3RhdGU7IGl0IGlzIGlnbm9yZWQnKSA6IHZvaWQgMDtcbiAgICB2YXIgYWN0aW9uID0gJ1JFUExBQ0UnO1xuICAgIHZhciBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHBhdGgsIHN0YXRlLCBjcmVhdGVLZXkoKSwgaGlzdG9yeS5sb2NhdGlvbik7XG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmICghb2spIHJldHVybjtcbiAgICAgIHZhciBocmVmID0gY3JlYXRlSHJlZihsb2NhdGlvbik7XG4gICAgICB2YXIga2V5ID0gbG9jYXRpb24ua2V5LFxuICAgICAgICAgIHN0YXRlID0gbG9jYXRpb24uc3RhdGU7XG5cbiAgICAgIGlmIChjYW5Vc2VIaXN0b3J5KSB7XG4gICAgICAgIGdsb2JhbEhpc3RvcnkucmVwbGFjZVN0YXRlKHtcbiAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICBzdGF0ZTogc3RhdGVcbiAgICAgICAgfSwgbnVsbCwgaHJlZik7XG5cbiAgICAgICAgaWYgKGZvcmNlUmVmcmVzaCkge1xuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKGhyZWYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwcmV2SW5kZXggPSBhbGxLZXlzLmluZGV4T2YoaGlzdG9yeS5sb2NhdGlvbi5rZXkpO1xuICAgICAgICAgIGlmIChwcmV2SW5kZXggIT09IC0xKSBhbGxLZXlzW3ByZXZJbmRleF0gPSBsb2NhdGlvbi5rZXk7XG4gICAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgICAgICBsb2NhdGlvbjogbG9jYXRpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhzdGF0ZSA9PT0gdW5kZWZpbmVkLCAnQnJvd3NlciBoaXN0b3J5IGNhbm5vdCByZXBsYWNlIHN0YXRlIGluIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgSFRNTDUgaGlzdG9yeScpIDogdm9pZCAwO1xuICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZShocmVmKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdvKG4pIHtcbiAgICBnbG9iYWxIaXN0b3J5LmdvKG4pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ29CYWNrKCkge1xuICAgIGdvKC0xKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdvRm9yd2FyZCgpIHtcbiAgICBnbygxKTtcbiAgfVxuXG4gIHZhciBsaXN0ZW5lckNvdW50ID0gMDtcblxuICBmdW5jdGlvbiBjaGVja0RPTUxpc3RlbmVycyhkZWx0YSkge1xuICAgIGxpc3RlbmVyQ291bnQgKz0gZGVsdGE7XG5cbiAgICBpZiAobGlzdGVuZXJDb3VudCA9PT0gMSAmJiBkZWx0YSA9PT0gMSkge1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoUG9wU3RhdGVFdmVudCwgaGFuZGxlUG9wU3RhdGUpO1xuICAgICAgaWYgKG5lZWRzSGFzaENoYW5nZUxpc3RlbmVyKSB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihIYXNoQ2hhbmdlRXZlbnQsIGhhbmRsZUhhc2hDaGFuZ2UpO1xuICAgIH0gZWxzZSBpZiAobGlzdGVuZXJDb3VudCA9PT0gMCkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoUG9wU3RhdGVFdmVudCwgaGFuZGxlUG9wU3RhdGUpO1xuICAgICAgaWYgKG5lZWRzSGFzaENoYW5nZUxpc3RlbmVyKSB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihIYXNoQ2hhbmdlRXZlbnQsIGhhbmRsZUhhc2hDaGFuZ2UpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBpc0Jsb2NrZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBibG9jayhwcm9tcHQpIHtcbiAgICBpZiAocHJvbXB0ID09PSB2b2lkIDApIHtcbiAgICAgIHByb21wdCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciB1bmJsb2NrID0gdHJhbnNpdGlvbk1hbmFnZXIuc2V0UHJvbXB0KHByb21wdCk7XG5cbiAgICBpZiAoIWlzQmxvY2tlZCkge1xuICAgICAgY2hlY2tET01MaXN0ZW5lcnMoMSk7XG4gICAgICBpc0Jsb2NrZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaXNCbG9ja2VkKSB7XG4gICAgICAgIGlzQmxvY2tlZCA9IGZhbHNlO1xuICAgICAgICBjaGVja0RPTUxpc3RlbmVycygtMSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1bmJsb2NrKCk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgIHZhciB1bmxpc3RlbiA9IHRyYW5zaXRpb25NYW5hZ2VyLmFwcGVuZExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICBjaGVja0RPTUxpc3RlbmVycygxKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgY2hlY2tET01MaXN0ZW5lcnMoLTEpO1xuICAgICAgdW5saXN0ZW4oKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIGhpc3RvcnkgPSB7XG4gICAgbGVuZ3RoOiBnbG9iYWxIaXN0b3J5Lmxlbmd0aCxcbiAgICBhY3Rpb246ICdQT1AnLFxuICAgIGxvY2F0aW9uOiBpbml0aWFsTG9jYXRpb24sXG4gICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcbiAgICBwdXNoOiBwdXNoLFxuICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgZ286IGdvLFxuICAgIGdvQmFjazogZ29CYWNrLFxuICAgIGdvRm9yd2FyZDogZ29Gb3J3YXJkLFxuICAgIGJsb2NrOiBibG9jayxcbiAgICBsaXN0ZW46IGxpc3RlblxuICB9O1xuICByZXR1cm4gaGlzdG9yeTtcbn1cblxudmFyIEhhc2hDaGFuZ2VFdmVudCQxID0gJ2hhc2hjaGFuZ2UnO1xudmFyIEhhc2hQYXRoQ29kZXJzID0ge1xuICBoYXNoYmFuZzoge1xuICAgIGVuY29kZVBhdGg6IGZ1bmN0aW9uIGVuY29kZVBhdGgocGF0aCkge1xuICAgICAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnIScgPyBwYXRoIDogJyEvJyArIHN0cmlwTGVhZGluZ1NsYXNoKHBhdGgpO1xuICAgIH0sXG4gICAgZGVjb2RlUGF0aDogZnVuY3Rpb24gZGVjb2RlUGF0aChwYXRoKSB7XG4gICAgICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICchJyA/IHBhdGguc3Vic3RyKDEpIDogcGF0aDtcbiAgICB9XG4gIH0sXG4gIG5vc2xhc2g6IHtcbiAgICBlbmNvZGVQYXRoOiBzdHJpcExlYWRpbmdTbGFzaCxcbiAgICBkZWNvZGVQYXRoOiBhZGRMZWFkaW5nU2xhc2hcbiAgfSxcbiAgc2xhc2g6IHtcbiAgICBlbmNvZGVQYXRoOiBhZGRMZWFkaW5nU2xhc2gsXG4gICAgZGVjb2RlUGF0aDogYWRkTGVhZGluZ1NsYXNoXG4gIH1cbn07XG5cbmZ1bmN0aW9uIHN0cmlwSGFzaCh1cmwpIHtcbiAgdmFyIGhhc2hJbmRleCA9IHVybC5pbmRleE9mKCcjJyk7XG4gIHJldHVybiBoYXNoSW5kZXggPT09IC0xID8gdXJsIDogdXJsLnNsaWNlKDAsIGhhc2hJbmRleCk7XG59XG5cbmZ1bmN0aW9uIGdldEhhc2hQYXRoKCkge1xuICAvLyBXZSBjYW4ndCB1c2Ugd2luZG93LmxvY2F0aW9uLmhhc2ggaGVyZSBiZWNhdXNlIGl0J3Mgbm90XG4gIC8vIGNvbnNpc3RlbnQgYWNyb3NzIGJyb3dzZXJzIC0gRmlyZWZveCB3aWxsIHByZS1kZWNvZGUgaXQhXG4gIHZhciBocmVmID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gIHZhciBoYXNoSW5kZXggPSBocmVmLmluZGV4T2YoJyMnKTtcbiAgcmV0dXJuIGhhc2hJbmRleCA9PT0gLTEgPyAnJyA6IGhyZWYuc3Vic3RyaW5nKGhhc2hJbmRleCArIDEpO1xufVxuXG5mdW5jdGlvbiBwdXNoSGFzaFBhdGgocGF0aCkge1xuICB3aW5kb3cubG9jYXRpb24uaGFzaCA9IHBhdGg7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VIYXNoUGF0aChwYXRoKSB7XG4gIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKHN0cmlwSGFzaCh3aW5kb3cubG9jYXRpb24uaHJlZikgKyAnIycgKyBwYXRoKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSGFzaEhpc3RvcnkocHJvcHMpIHtcbiAgaWYgKHByb3BzID09PSB2b2lkIDApIHtcbiAgICBwcm9wcyA9IHt9O1xuICB9XG5cbiAgIWNhblVzZURPTSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0hhc2ggaGlzdG9yeSBuZWVkcyBhIERPTScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgdmFyIGdsb2JhbEhpc3RvcnkgPSB3aW5kb3cuaGlzdG9yeTtcbiAgdmFyIGNhbkdvV2l0aG91dFJlbG9hZCA9IHN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoKCk7XG4gIHZhciBfcHJvcHMgPSBwcm9wcyxcbiAgICAgIF9wcm9wcyRnZXRVc2VyQ29uZmlybSA9IF9wcm9wcy5nZXRVc2VyQ29uZmlybWF0aW9uLFxuICAgICAgZ2V0VXNlckNvbmZpcm1hdGlvbiA9IF9wcm9wcyRnZXRVc2VyQ29uZmlybSA9PT0gdm9pZCAwID8gZ2V0Q29uZmlybWF0aW9uIDogX3Byb3BzJGdldFVzZXJDb25maXJtLFxuICAgICAgX3Byb3BzJGhhc2hUeXBlID0gX3Byb3BzLmhhc2hUeXBlLFxuICAgICAgaGFzaFR5cGUgPSBfcHJvcHMkaGFzaFR5cGUgPT09IHZvaWQgMCA/ICdzbGFzaCcgOiBfcHJvcHMkaGFzaFR5cGU7XG4gIHZhciBiYXNlbmFtZSA9IHByb3BzLmJhc2VuYW1lID8gc3RyaXBUcmFpbGluZ1NsYXNoKGFkZExlYWRpbmdTbGFzaChwcm9wcy5iYXNlbmFtZSkpIDogJyc7XG4gIHZhciBfSGFzaFBhdGhDb2RlcnMkaGFzaFQgPSBIYXNoUGF0aENvZGVyc1toYXNoVHlwZV0sXG4gICAgICBlbmNvZGVQYXRoID0gX0hhc2hQYXRoQ29kZXJzJGhhc2hULmVuY29kZVBhdGgsXG4gICAgICBkZWNvZGVQYXRoID0gX0hhc2hQYXRoQ29kZXJzJGhhc2hULmRlY29kZVBhdGg7XG5cbiAgZnVuY3Rpb24gZ2V0RE9NTG9jYXRpb24oKSB7XG4gICAgdmFyIHBhdGggPSBkZWNvZGVQYXRoKGdldEhhc2hQYXRoKCkpO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoIWJhc2VuYW1lIHx8IGhhc0Jhc2VuYW1lKHBhdGgsIGJhc2VuYW1lKSwgJ1lvdSBhcmUgYXR0ZW1wdGluZyB0byB1c2UgYSBiYXNlbmFtZSBvbiBhIHBhZ2Ugd2hvc2UgVVJMIHBhdGggZG9lcyBub3QgYmVnaW4gJyArICd3aXRoIHRoZSBiYXNlbmFtZS4gRXhwZWN0ZWQgcGF0aCBcIicgKyBwYXRoICsgJ1wiIHRvIGJlZ2luIHdpdGggXCInICsgYmFzZW5hbWUgKyAnXCIuJykgOiB2b2lkIDA7XG4gICAgaWYgKGJhc2VuYW1lKSBwYXRoID0gc3RyaXBCYXNlbmFtZShwYXRoLCBiYXNlbmFtZSk7XG4gICAgcmV0dXJuIGNyZWF0ZUxvY2F0aW9uKHBhdGgpO1xuICB9XG5cbiAgdmFyIHRyYW5zaXRpb25NYW5hZ2VyID0gY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIoKTtcblxuICBmdW5jdGlvbiBzZXRTdGF0ZShuZXh0U3RhdGUpIHtcbiAgICBfZXh0ZW5kcyhoaXN0b3J5LCBuZXh0U3RhdGUpO1xuXG4gICAgaGlzdG9yeS5sZW5ndGggPSBnbG9iYWxIaXN0b3J5Lmxlbmd0aDtcbiAgICB0cmFuc2l0aW9uTWFuYWdlci5ub3RpZnlMaXN0ZW5lcnMoaGlzdG9yeS5sb2NhdGlvbiwgaGlzdG9yeS5hY3Rpb24pO1xuICB9XG5cbiAgdmFyIGZvcmNlTmV4dFBvcCA9IGZhbHNlO1xuICB2YXIgaWdub3JlUGF0aCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gbG9jYXRpb25zQXJlRXF1YWwkJDEoYSwgYikge1xuICAgIHJldHVybiBhLnBhdGhuYW1lID09PSBiLnBhdGhuYW1lICYmIGEuc2VhcmNoID09PSBiLnNlYXJjaCAmJiBhLmhhc2ggPT09IGIuaGFzaDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUhhc2hDaGFuZ2UoKSB7XG4gICAgdmFyIHBhdGggPSBnZXRIYXNoUGF0aCgpO1xuICAgIHZhciBlbmNvZGVkUGF0aCA9IGVuY29kZVBhdGgocGF0aCk7XG5cbiAgICBpZiAocGF0aCAhPT0gZW5jb2RlZFBhdGgpIHtcbiAgICAgIC8vIEVuc3VyZSB3ZSBhbHdheXMgaGF2ZSBhIHByb3Blcmx5LWVuY29kZWQgaGFzaC5cbiAgICAgIHJlcGxhY2VIYXNoUGF0aChlbmNvZGVkUGF0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsb2NhdGlvbiA9IGdldERPTUxvY2F0aW9uKCk7XG4gICAgICB2YXIgcHJldkxvY2F0aW9uID0gaGlzdG9yeS5sb2NhdGlvbjtcbiAgICAgIGlmICghZm9yY2VOZXh0UG9wICYmIGxvY2F0aW9uc0FyZUVxdWFsJCQxKHByZXZMb2NhdGlvbiwgbG9jYXRpb24pKSByZXR1cm47IC8vIEEgaGFzaGNoYW5nZSBkb2Vzbid0IGFsd2F5cyA9PSBsb2NhdGlvbiBjaGFuZ2UuXG5cbiAgICAgIGlmIChpZ25vcmVQYXRoID09PSBjcmVhdGVQYXRoKGxvY2F0aW9uKSkgcmV0dXJuOyAvLyBJZ25vcmUgdGhpcyBjaGFuZ2U7IHdlIGFscmVhZHkgc2V0U3RhdGUgaW4gcHVzaC9yZXBsYWNlLlxuXG4gICAgICBpZ25vcmVQYXRoID0gbnVsbDtcbiAgICAgIGhhbmRsZVBvcChsb2NhdGlvbik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlUG9wKGxvY2F0aW9uKSB7XG4gICAgaWYgKGZvcmNlTmV4dFBvcCkge1xuICAgICAgZm9yY2VOZXh0UG9wID0gZmFsc2U7XG4gICAgICBzZXRTdGF0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYWN0aW9uID0gJ1BPUCc7XG4gICAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgICBpZiAob2spIHtcbiAgICAgICAgICBzZXRTdGF0ZSh7XG4gICAgICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvblxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldmVydFBvcChsb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJldmVydFBvcChmcm9tTG9jYXRpb24pIHtcbiAgICB2YXIgdG9Mb2NhdGlvbiA9IGhpc3RvcnkubG9jYXRpb247IC8vIFRPRE86IFdlIGNvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyBtb3JlIHJlbGlhYmxlIGJ5XG4gICAgLy8ga2VlcGluZyBhIGxpc3Qgb2YgcGF0aHMgd2UndmUgc2VlbiBpbiBzZXNzaW9uU3RvcmFnZS5cbiAgICAvLyBJbnN0ZWFkLCB3ZSBqdXN0IGRlZmF1bHQgdG8gMCBmb3IgcGF0aHMgd2UgZG9uJ3Qga25vdy5cblxuICAgIHZhciB0b0luZGV4ID0gYWxsUGF0aHMubGFzdEluZGV4T2YoY3JlYXRlUGF0aCh0b0xvY2F0aW9uKSk7XG4gICAgaWYgKHRvSW5kZXggPT09IC0xKSB0b0luZGV4ID0gMDtcbiAgICB2YXIgZnJvbUluZGV4ID0gYWxsUGF0aHMubGFzdEluZGV4T2YoY3JlYXRlUGF0aChmcm9tTG9jYXRpb24pKTtcbiAgICBpZiAoZnJvbUluZGV4ID09PSAtMSkgZnJvbUluZGV4ID0gMDtcbiAgICB2YXIgZGVsdGEgPSB0b0luZGV4IC0gZnJvbUluZGV4O1xuXG4gICAgaWYgKGRlbHRhKSB7XG4gICAgICBmb3JjZU5leHRQb3AgPSB0cnVlO1xuICAgICAgZ28oZGVsdGEpO1xuICAgIH1cbiAgfSAvLyBFbnN1cmUgdGhlIGhhc2ggaXMgZW5jb2RlZCBwcm9wZXJseSBiZWZvcmUgZG9pbmcgYW55dGhpbmcgZWxzZS5cblxuXG4gIHZhciBwYXRoID0gZ2V0SGFzaFBhdGgoKTtcbiAgdmFyIGVuY29kZWRQYXRoID0gZW5jb2RlUGF0aChwYXRoKTtcbiAgaWYgKHBhdGggIT09IGVuY29kZWRQYXRoKSByZXBsYWNlSGFzaFBhdGgoZW5jb2RlZFBhdGgpO1xuICB2YXIgaW5pdGlhbExvY2F0aW9uID0gZ2V0RE9NTG9jYXRpb24oKTtcbiAgdmFyIGFsbFBhdGhzID0gW2NyZWF0ZVBhdGgoaW5pdGlhbExvY2F0aW9uKV07IC8vIFB1YmxpYyBpbnRlcmZhY2VcblxuICBmdW5jdGlvbiBjcmVhdGVIcmVmKGxvY2F0aW9uKSB7XG4gICAgdmFyIGJhc2VUYWcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdiYXNlJyk7XG4gICAgdmFyIGhyZWYgPSAnJztcblxuICAgIGlmIChiYXNlVGFnICYmIGJhc2VUYWcuZ2V0QXR0cmlidXRlKCdocmVmJykpIHtcbiAgICAgIGhyZWYgPSBzdHJpcEhhc2god2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgIH1cblxuICAgIHJldHVybiBocmVmICsgJyMnICsgZW5jb2RlUGF0aChiYXNlbmFtZSArIGNyZWF0ZVBhdGgobG9jYXRpb24pKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2gocGF0aCwgc3RhdGUpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKHN0YXRlID09PSB1bmRlZmluZWQsICdIYXNoIGhpc3RvcnkgY2Fubm90IHB1c2ggc3RhdGU7IGl0IGlzIGlnbm9yZWQnKSA6IHZvaWQgMDtcbiAgICB2YXIgYWN0aW9uID0gJ1BVU0gnO1xuICAgIHZhciBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHBhdGgsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBoaXN0b3J5LmxvY2F0aW9uKTtcbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuICAgICAgdmFyIHBhdGggPSBjcmVhdGVQYXRoKGxvY2F0aW9uKTtcbiAgICAgIHZhciBlbmNvZGVkUGF0aCA9IGVuY29kZVBhdGgoYmFzZW5hbWUgKyBwYXRoKTtcbiAgICAgIHZhciBoYXNoQ2hhbmdlZCA9IGdldEhhc2hQYXRoKCkgIT09IGVuY29kZWRQYXRoO1xuXG4gICAgICBpZiAoaGFzaENoYW5nZWQpIHtcbiAgICAgICAgLy8gV2UgY2Fubm90IHRlbGwgaWYgYSBoYXNoY2hhbmdlIHdhcyBjYXVzZWQgYnkgYSBQVVNILCBzbyB3ZSdkXG4gICAgICAgIC8vIHJhdGhlciBzZXRTdGF0ZSBoZXJlIGFuZCBpZ25vcmUgdGhlIGhhc2hjaGFuZ2UuIFRoZSBjYXZlYXQgaGVyZVxuICAgICAgICAvLyBpcyB0aGF0IG90aGVyIGhhc2ggaGlzdG9yaWVzIGluIHRoZSBwYWdlIHdpbGwgY29uc2lkZXIgaXQgYSBQT1AuXG4gICAgICAgIGlnbm9yZVBhdGggPSBwYXRoO1xuICAgICAgICBwdXNoSGFzaFBhdGgoZW5jb2RlZFBhdGgpO1xuICAgICAgICB2YXIgcHJldkluZGV4ID0gYWxsUGF0aHMubGFzdEluZGV4T2YoY3JlYXRlUGF0aChoaXN0b3J5LmxvY2F0aW9uKSk7XG4gICAgICAgIHZhciBuZXh0UGF0aHMgPSBhbGxQYXRocy5zbGljZSgwLCBwcmV2SW5kZXggKyAxKTtcbiAgICAgICAgbmV4dFBhdGhzLnB1c2gocGF0aCk7XG4gICAgICAgIGFsbFBhdGhzID0gbmV4dFBhdGhzO1xuICAgICAgICBzZXRTdGF0ZSh7XG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgJ0hhc2ggaGlzdG9yeSBjYW5ub3QgUFVTSCB0aGUgc2FtZSBwYXRoOyBhIG5ldyBlbnRyeSB3aWxsIG5vdCBiZSBhZGRlZCB0byB0aGUgaGlzdG9yeSBzdGFjaycpIDogdm9pZCAwO1xuICAgICAgICBzZXRTdGF0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVwbGFjZShwYXRoLCBzdGF0ZSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoc3RhdGUgPT09IHVuZGVmaW5lZCwgJ0hhc2ggaGlzdG9yeSBjYW5ub3QgcmVwbGFjZSBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpIDogdm9pZCAwO1xuICAgIHZhciBhY3Rpb24gPSAnUkVQTEFDRSc7XG4gICAgdmFyIGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24ocGF0aCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGhpc3RvcnkubG9jYXRpb24pO1xuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAoIW9rKSByZXR1cm47XG4gICAgICB2YXIgcGF0aCA9IGNyZWF0ZVBhdGgobG9jYXRpb24pO1xuICAgICAgdmFyIGVuY29kZWRQYXRoID0gZW5jb2RlUGF0aChiYXNlbmFtZSArIHBhdGgpO1xuICAgICAgdmFyIGhhc2hDaGFuZ2VkID0gZ2V0SGFzaFBhdGgoKSAhPT0gZW5jb2RlZFBhdGg7XG5cbiAgICAgIGlmIChoYXNoQ2hhbmdlZCkge1xuICAgICAgICAvLyBXZSBjYW5ub3QgdGVsbCBpZiBhIGhhc2hjaGFuZ2Ugd2FzIGNhdXNlZCBieSBhIFJFUExBQ0UsIHNvIHdlJ2RcbiAgICAgICAgLy8gcmF0aGVyIHNldFN0YXRlIGhlcmUgYW5kIGlnbm9yZSB0aGUgaGFzaGNoYW5nZS4gVGhlIGNhdmVhdCBoZXJlXG4gICAgICAgIC8vIGlzIHRoYXQgb3RoZXIgaGFzaCBoaXN0b3JpZXMgaW4gdGhlIHBhZ2Ugd2lsbCBjb25zaWRlciBpdCBhIFBPUC5cbiAgICAgICAgaWdub3JlUGF0aCA9IHBhdGg7XG4gICAgICAgIHJlcGxhY2VIYXNoUGF0aChlbmNvZGVkUGF0aCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcmV2SW5kZXggPSBhbGxQYXRocy5pbmRleE9mKGNyZWF0ZVBhdGgoaGlzdG9yeS5sb2NhdGlvbikpO1xuICAgICAgaWYgKHByZXZJbmRleCAhPT0gLTEpIGFsbFBhdGhzW3ByZXZJbmRleF0gPSBwYXRoO1xuICAgICAgc2V0U3RhdGUoe1xuICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdvKG4pIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGNhbkdvV2l0aG91dFJlbG9hZCwgJ0hhc2ggaGlzdG9yeSBnbyhuKSBjYXVzZXMgYSBmdWxsIHBhZ2UgcmVsb2FkIGluIHRoaXMgYnJvd3NlcicpIDogdm9pZCAwO1xuICAgIGdsb2JhbEhpc3RvcnkuZ28obik7XG4gIH1cblxuICBmdW5jdGlvbiBnb0JhY2soKSB7XG4gICAgZ28oLTEpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ29Gb3J3YXJkKCkge1xuICAgIGdvKDEpO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVyQ291bnQgPSAwO1xuXG4gIGZ1bmN0aW9uIGNoZWNrRE9NTGlzdGVuZXJzKGRlbHRhKSB7XG4gICAgbGlzdGVuZXJDb3VudCArPSBkZWx0YTtcblxuICAgIGlmIChsaXN0ZW5lckNvdW50ID09PSAxICYmIGRlbHRhID09PSAxKSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihIYXNoQ2hhbmdlRXZlbnQkMSwgaGFuZGxlSGFzaENoYW5nZSk7XG4gICAgfSBlbHNlIGlmIChsaXN0ZW5lckNvdW50ID09PSAwKSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihIYXNoQ2hhbmdlRXZlbnQkMSwgaGFuZGxlSGFzaENoYW5nZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGlzQmxvY2tlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGJsb2NrKHByb21wdCkge1xuICAgIGlmIChwcm9tcHQgPT09IHZvaWQgMCkge1xuICAgICAgcHJvbXB0ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHVuYmxvY2sgPSB0cmFuc2l0aW9uTWFuYWdlci5zZXRQcm9tcHQocHJvbXB0KTtcblxuICAgIGlmICghaXNCbG9ja2VkKSB7XG4gICAgICBjaGVja0RPTUxpc3RlbmVycygxKTtcbiAgICAgIGlzQmxvY2tlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpc0Jsb2NrZWQpIHtcbiAgICAgICAgaXNCbG9ja2VkID0gZmFsc2U7XG4gICAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKC0xKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVuYmxvY2soKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgdmFyIHVubGlzdGVuID0gdHJhbnNpdGlvbk1hbmFnZXIuYXBwZW5kTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgIGNoZWNrRE9NTGlzdGVuZXJzKDEpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBjaGVja0RPTUxpc3RlbmVycygtMSk7XG4gICAgICB1bmxpc3RlbigpO1xuICAgIH07XG4gIH1cblxuICB2YXIgaGlzdG9yeSA9IHtcbiAgICBsZW5ndGg6IGdsb2JhbEhpc3RvcnkubGVuZ3RoLFxuICAgIGFjdGlvbjogJ1BPUCcsXG4gICAgbG9jYXRpb246IGluaXRpYWxMb2NhdGlvbixcbiAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmLFxuICAgIHB1c2g6IHB1c2gsXG4gICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICBnbzogZ28sXG4gICAgZ29CYWNrOiBnb0JhY2ssXG4gICAgZ29Gb3J3YXJkOiBnb0ZvcndhcmQsXG4gICAgYmxvY2s6IGJsb2NrLFxuICAgIGxpc3RlbjogbGlzdGVuXG4gIH07XG4gIHJldHVybiBoaXN0b3J5O1xufVxuXG5mdW5jdGlvbiBjbGFtcChuLCBsb3dlckJvdW5kLCB1cHBlckJvdW5kKSB7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChuLCBsb3dlckJvdW5kKSwgdXBwZXJCb3VuZCk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBoaXN0b3J5IG9iamVjdCB0aGF0IHN0b3JlcyBsb2NhdGlvbnMgaW4gbWVtb3J5LlxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlTWVtb3J5SGlzdG9yeShwcm9wcykge1xuICBpZiAocHJvcHMgPT09IHZvaWQgMCkge1xuICAgIHByb3BzID0ge307XG4gIH1cblxuICB2YXIgX3Byb3BzID0gcHJvcHMsXG4gICAgICBnZXRVc2VyQ29uZmlybWF0aW9uID0gX3Byb3BzLmdldFVzZXJDb25maXJtYXRpb24sXG4gICAgICBfcHJvcHMkaW5pdGlhbEVudHJpZXMgPSBfcHJvcHMuaW5pdGlhbEVudHJpZXMsXG4gICAgICBpbml0aWFsRW50cmllcyA9IF9wcm9wcyRpbml0aWFsRW50cmllcyA9PT0gdm9pZCAwID8gWycvJ10gOiBfcHJvcHMkaW5pdGlhbEVudHJpZXMsXG4gICAgICBfcHJvcHMkaW5pdGlhbEluZGV4ID0gX3Byb3BzLmluaXRpYWxJbmRleCxcbiAgICAgIGluaXRpYWxJbmRleCA9IF9wcm9wcyRpbml0aWFsSW5kZXggPT09IHZvaWQgMCA/IDAgOiBfcHJvcHMkaW5pdGlhbEluZGV4LFxuICAgICAgX3Byb3BzJGtleUxlbmd0aCA9IF9wcm9wcy5rZXlMZW5ndGgsXG4gICAgICBrZXlMZW5ndGggPSBfcHJvcHMka2V5TGVuZ3RoID09PSB2b2lkIDAgPyA2IDogX3Byb3BzJGtleUxlbmd0aDtcbiAgdmFyIHRyYW5zaXRpb25NYW5hZ2VyID0gY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIoKTtcblxuICBmdW5jdGlvbiBzZXRTdGF0ZShuZXh0U3RhdGUpIHtcbiAgICBfZXh0ZW5kcyhoaXN0b3J5LCBuZXh0U3RhdGUpO1xuXG4gICAgaGlzdG9yeS5sZW5ndGggPSBoaXN0b3J5LmVudHJpZXMubGVuZ3RoO1xuICAgIHRyYW5zaXRpb25NYW5hZ2VyLm5vdGlmeUxpc3RlbmVycyhoaXN0b3J5LmxvY2F0aW9uLCBoaXN0b3J5LmFjdGlvbik7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVLZXkoKSB7XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCBrZXlMZW5ndGgpO1xuICB9XG5cbiAgdmFyIGluZGV4ID0gY2xhbXAoaW5pdGlhbEluZGV4LCAwLCBpbml0aWFsRW50cmllcy5sZW5ndGggLSAxKTtcbiAgdmFyIGVudHJpZXMgPSBpbml0aWFsRW50cmllcy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBlbnRyeSA9PT0gJ3N0cmluZycgPyBjcmVhdGVMb2NhdGlvbihlbnRyeSwgdW5kZWZpbmVkLCBjcmVhdGVLZXkoKSkgOiBjcmVhdGVMb2NhdGlvbihlbnRyeSwgdW5kZWZpbmVkLCBlbnRyeS5rZXkgfHwgY3JlYXRlS2V5KCkpO1xuICB9KTsgLy8gUHVibGljIGludGVyZmFjZVxuXG4gIHZhciBjcmVhdGVIcmVmID0gY3JlYXRlUGF0aDtcblxuICBmdW5jdGlvbiBwdXNoKHBhdGgsIHN0YXRlKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyghKHR5cGVvZiBwYXRoID09PSAnb2JqZWN0JyAmJiBwYXRoLnN0YXRlICE9PSB1bmRlZmluZWQgJiYgc3RhdGUgIT09IHVuZGVmaW5lZCksICdZb3Ugc2hvdWxkIGF2b2lkIHByb3ZpZGluZyBhIDJuZCBzdGF0ZSBhcmd1bWVudCB0byBwdXNoIHdoZW4gdGhlIDFzdCAnICsgJ2FyZ3VtZW50IGlzIGEgbG9jYXRpb24tbGlrZSBvYmplY3QgdGhhdCBhbHJlYWR5IGhhcyBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpIDogdm9pZCAwO1xuICAgIHZhciBhY3Rpb24gPSAnUFVTSCc7XG4gICAgdmFyIGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24ocGF0aCwgc3RhdGUsIGNyZWF0ZUtleSgpLCBoaXN0b3J5LmxvY2F0aW9uKTtcbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuICAgICAgdmFyIHByZXZJbmRleCA9IGhpc3RvcnkuaW5kZXg7XG4gICAgICB2YXIgbmV4dEluZGV4ID0gcHJldkluZGV4ICsgMTtcbiAgICAgIHZhciBuZXh0RW50cmllcyA9IGhpc3RvcnkuZW50cmllcy5zbGljZSgwKTtcblxuICAgICAgaWYgKG5leHRFbnRyaWVzLmxlbmd0aCA+IG5leHRJbmRleCkge1xuICAgICAgICBuZXh0RW50cmllcy5zcGxpY2UobmV4dEluZGV4LCBuZXh0RW50cmllcy5sZW5ndGggLSBuZXh0SW5kZXgsIGxvY2F0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRFbnRyaWVzLnB1c2gobG9jYXRpb24pO1xuICAgICAgfVxuXG4gICAgICBzZXRTdGF0ZSh7XG4gICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICAgIGluZGV4OiBuZXh0SW5kZXgsXG4gICAgICAgIGVudHJpZXM6IG5leHRFbnRyaWVzXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlcGxhY2UocGF0aCwgc3RhdGUpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCEodHlwZW9mIHBhdGggPT09ICdvYmplY3QnICYmIHBhdGguc3RhdGUgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZSAhPT0gdW5kZWZpbmVkKSwgJ1lvdSBzaG91bGQgYXZvaWQgcHJvdmlkaW5nIGEgMm5kIHN0YXRlIGFyZ3VtZW50IHRvIHJlcGxhY2Ugd2hlbiB0aGUgMXN0ICcgKyAnYXJndW1lbnQgaXMgYSBsb2NhdGlvbi1saWtlIG9iamVjdCB0aGF0IGFscmVhZHkgaGFzIHN0YXRlOyBpdCBpcyBpZ25vcmVkJykgOiB2b2lkIDA7XG4gICAgdmFyIGFjdGlvbiA9ICdSRVBMQUNFJztcbiAgICB2YXIgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihwYXRoLCBzdGF0ZSwgY3JlYXRlS2V5KCksIGhpc3RvcnkubG9jYXRpb24pO1xuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAoIW9rKSByZXR1cm47XG4gICAgICBoaXN0b3J5LmVudHJpZXNbaGlzdG9yeS5pbmRleF0gPSBsb2NhdGlvbjtcbiAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvblxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnbyhuKSB7XG4gICAgdmFyIG5leHRJbmRleCA9IGNsYW1wKGhpc3RvcnkuaW5kZXggKyBuLCAwLCBoaXN0b3J5LmVudHJpZXMubGVuZ3RoIC0gMSk7XG4gICAgdmFyIGFjdGlvbiA9ICdQT1AnO1xuICAgIHZhciBsb2NhdGlvbiA9IGhpc3RvcnkuZW50cmllc1tuZXh0SW5kZXhdO1xuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAob2spIHtcbiAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgICBpbmRleDogbmV4dEluZGV4XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTWltaWMgdGhlIGJlaGF2aW9yIG9mIERPTSBoaXN0b3JpZXMgYnlcbiAgICAgICAgLy8gY2F1c2luZyBhIHJlbmRlciBhZnRlciBhIGNhbmNlbGxlZCBQT1AuXG4gICAgICAgIHNldFN0YXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnb0JhY2soKSB7XG4gICAgZ28oLTEpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ29Gb3J3YXJkKCkge1xuICAgIGdvKDEpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuR28obikge1xuICAgIHZhciBuZXh0SW5kZXggPSBoaXN0b3J5LmluZGV4ICsgbjtcbiAgICByZXR1cm4gbmV4dEluZGV4ID49IDAgJiYgbmV4dEluZGV4IDwgaGlzdG9yeS5lbnRyaWVzLmxlbmd0aDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJsb2NrKHByb21wdCkge1xuICAgIGlmIChwcm9tcHQgPT09IHZvaWQgMCkge1xuICAgICAgcHJvbXB0ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRyYW5zaXRpb25NYW5hZ2VyLnNldFByb21wdChwcm9tcHQpO1xuICB9XG5cbiAgZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25NYW5hZ2VyLmFwcGVuZExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgfVxuXG4gIHZhciBoaXN0b3J5ID0ge1xuICAgIGxlbmd0aDogZW50cmllcy5sZW5ndGgsXG4gICAgYWN0aW9uOiAnUE9QJyxcbiAgICBsb2NhdGlvbjogZW50cmllc1tpbmRleF0sXG4gICAgaW5kZXg6IGluZGV4LFxuICAgIGVudHJpZXM6IGVudHJpZXMsXG4gICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcbiAgICBwdXNoOiBwdXNoLFxuICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgZ286IGdvLFxuICAgIGdvQmFjazogZ29CYWNrLFxuICAgIGdvRm9yd2FyZDogZ29Gb3J3YXJkLFxuICAgIGNhbkdvOiBjYW5HbyxcbiAgICBibG9jazogYmxvY2ssXG4gICAgbGlzdGVuOiBsaXN0ZW5cbiAgfTtcbiAgcmV0dXJuIGhpc3Rvcnk7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZUJyb3dzZXJIaXN0b3J5LCBjcmVhdGVIYXNoSGlzdG9yeSwgY3JlYXRlTWVtb3J5SGlzdG9yeSwgY3JlYXRlTG9jYXRpb24sIGxvY2F0aW9uc0FyZUVxdWFsLCBwYXJzZVBhdGgsIGNyZWF0ZVBhdGggfTtcbiJdLCJuYW1lcyI6WyJfZXh0ZW5kcyIsInJlc29sdmVQYXRobmFtZSIsInZhbHVlRXF1YWwiLCJ3YXJuaW5nIiwiaW52YXJpYW50IiwiYWRkTGVhZGluZ1NsYXNoIiwicGF0aCIsImNoYXJBdCIsInN0cmlwTGVhZGluZ1NsYXNoIiwic3Vic3RyIiwiaGFzQmFzZW5hbWUiLCJwcmVmaXgiLCJ0b0xvd2VyQ2FzZSIsImluZGV4T2YiLCJsZW5ndGgiLCJzdHJpcEJhc2VuYW1lIiwic3RyaXBUcmFpbGluZ1NsYXNoIiwic2xpY2UiLCJwYXJzZVBhdGgiLCJwYXRobmFtZSIsInNlYXJjaCIsImhhc2giLCJoYXNoSW5kZXgiLCJzZWFyY2hJbmRleCIsImNyZWF0ZVBhdGgiLCJsb2NhdGlvbiIsImNyZWF0ZUxvY2F0aW9uIiwic3RhdGUiLCJrZXkiLCJjdXJyZW50TG9jYXRpb24iLCJ1bmRlZmluZWQiLCJkZWNvZGVVUkkiLCJlIiwiVVJJRXJyb3IiLCJsb2NhdGlvbnNBcmVFcXVhbCIsImEiLCJiIiwiY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIiLCJwcm9tcHQiLCJzZXRQcm9tcHQiLCJuZXh0UHJvbXB0IiwiY29uZmlybVRyYW5zaXRpb25UbyIsImFjdGlvbiIsImdldFVzZXJDb25maXJtYXRpb24iLCJjYWxsYmFjayIsInJlc3VsdCIsImxpc3RlbmVycyIsImFwcGVuZExpc3RlbmVyIiwiZm4iLCJpc0FjdGl2ZSIsImxpc3RlbmVyIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJwdXNoIiwiZmlsdGVyIiwiaXRlbSIsIm5vdGlmeUxpc3RlbmVycyIsIl9sZW4iLCJhcmdzIiwiQXJyYXkiLCJfa2V5IiwiZm9yRWFjaCIsImNhblVzZURPTSIsIndpbmRvdyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImdldENvbmZpcm1hdGlvbiIsIm1lc3NhZ2UiLCJjb25maXJtIiwic3VwcG9ydHNIaXN0b3J5IiwidWEiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJoaXN0b3J5Iiwic3VwcG9ydHNQb3BTdGF0ZU9uSGFzaENoYW5nZSIsInN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoIiwiaXNFeHRyYW5lb3VzUG9wc3RhdGVFdmVudCIsImV2ZW50IiwiUG9wU3RhdGVFdmVudCIsIkhhc2hDaGFuZ2VFdmVudCIsImdldEhpc3RvcnlTdGF0ZSIsImNyZWF0ZUJyb3dzZXJIaXN0b3J5IiwicHJvcHMiLCJwcm9jZXNzIiwiZ2xvYmFsSGlzdG9yeSIsImNhblVzZUhpc3RvcnkiLCJuZWVkc0hhc2hDaGFuZ2VMaXN0ZW5lciIsIl9wcm9wcyIsIl9wcm9wcyRmb3JjZVJlZnJlc2giLCJmb3JjZVJlZnJlc2giLCJfcHJvcHMkZ2V0VXNlckNvbmZpcm0iLCJfcHJvcHMka2V5TGVuZ3RoIiwia2V5TGVuZ3RoIiwiYmFzZW5hbWUiLCJnZXRET01Mb2NhdGlvbiIsImhpc3RvcnlTdGF0ZSIsIl9yZWYiLCJfd2luZG93JGxvY2F0aW9uIiwiY3JlYXRlS2V5IiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwidHJhbnNpdGlvbk1hbmFnZXIiLCJzZXRTdGF0ZSIsIm5leHRTdGF0ZSIsImhhbmRsZVBvcFN0YXRlIiwiaGFuZGxlUG9wIiwiaGFuZGxlSGFzaENoYW5nZSIsImZvcmNlTmV4dFBvcCIsIm9rIiwicmV2ZXJ0UG9wIiwiZnJvbUxvY2F0aW9uIiwidG9Mb2NhdGlvbiIsInRvSW5kZXgiLCJhbGxLZXlzIiwiZnJvbUluZGV4IiwiZGVsdGEiLCJnbyIsImluaXRpYWxMb2NhdGlvbiIsImNyZWF0ZUhyZWYiLCJocmVmIiwicHVzaFN0YXRlIiwicHJldkluZGV4IiwibmV4dEtleXMiLCJyZXBsYWNlIiwicmVwbGFjZVN0YXRlIiwibiIsImdvQmFjayIsImdvRm9yd2FyZCIsImxpc3RlbmVyQ291bnQiLCJjaGVja0RPTUxpc3RlbmVycyIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiaXNCbG9ja2VkIiwiYmxvY2siLCJ1bmJsb2NrIiwibGlzdGVuIiwidW5saXN0ZW4iLCJIYXNoQ2hhbmdlRXZlbnQkMSIsIkhhc2hQYXRoQ29kZXJzIiwiaGFzaGJhbmciLCJlbmNvZGVQYXRoIiwiZGVjb2RlUGF0aCIsIm5vc2xhc2giLCJzbGFzaCIsInN0cmlwSGFzaCIsInVybCIsImdldEhhc2hQYXRoIiwic3Vic3RyaW5nIiwicHVzaEhhc2hQYXRoIiwicmVwbGFjZUhhc2hQYXRoIiwiY3JlYXRlSGFzaEhpc3RvcnkiLCJjYW5Hb1dpdGhvdXRSZWxvYWQiLCJfcHJvcHMkaGFzaFR5cGUiLCJoYXNoVHlwZSIsIl9IYXNoUGF0aENvZGVycyRoYXNoVCIsImlnbm9yZVBhdGgiLCJsb2NhdGlvbnNBcmVFcXVhbCQkMSIsImVuY29kZWRQYXRoIiwicHJldkxvY2F0aW9uIiwiYWxsUGF0aHMiLCJsYXN0SW5kZXhPZiIsImJhc2VUYWciLCJxdWVyeVNlbGVjdG9yIiwiZ2V0QXR0cmlidXRlIiwiaGFzaENoYW5nZWQiLCJuZXh0UGF0aHMiLCJjbGFtcCIsImxvd2VyQm91bmQiLCJ1cHBlckJvdW5kIiwibWluIiwibWF4IiwiY3JlYXRlTWVtb3J5SGlzdG9yeSIsIl9wcm9wcyRpbml0aWFsRW50cmllcyIsImluaXRpYWxFbnRyaWVzIiwiX3Byb3BzJGluaXRpYWxJbmRleCIsImluaXRpYWxJbmRleCIsImVudHJpZXMiLCJpbmRleCIsIm1hcCIsImVudHJ5IiwibmV4dEluZGV4IiwibmV4dEVudHJpZXMiLCJzcGxpY2UiLCJjYW5HbyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/history/esm/history.js\n");

/***/ })

};
;